/*
Update
2020/01/19 素因数分解ライブラリがO(N)かかるバグを修正
2020/01/21 Modintを変数で指定可能なものに変更
2020/01/23 LCAの関数isTrailの用途を加筆
2020/01/24 テンプレートからMODを削除，Modintの998244353を修正
2020/01/27 Trieに辺集合のvectorとある文字列の個数を持つ変数を追加
2020/01/27 テンプレートにtupleを追加
2020/01/27 cin_vector_tupleを追加
2020/01/30 nxidを0-indexedに修正
2020/03/07 xorshiftを追加
2020/03/09 テンプレートにINFとLINFを追加
2020/03/11 2部グラフ判定を汎用的に(falseが確定してもdfsですべての頂点を訪問する)
2020/03/16 抽象化全方位木DPを追加　オーバーフロー検出を削除
2020/03/23 ライブラリのINFをLINFに修正
2020/06/28 modintにinitとcmbを追加
2020/07/07 chmin,chmaxがboolを返すように変更
2020/07/12 テンプレートをマルチケース仕様に変更
2020/07/16 テンプレートに開区間REP,FORを追加
2020/08/06 t_sortを構造体に変更
2020/08/12 NTTを追加
2020/08/15 segment treeの2分探索を修正
2020/08/18 FFTを修正(M_PIを定数に、なぜか追加されていたmodpowを削除)
2020/08/20 dijkstraを構造体に range_dijkstraを追加
2020/09/01 Convex Hull のバグ修正 
2020/09/07 dfsをラムダ式に
*/

{
    "cin_vector_int":{
        "prefix": "cvi",
        "body":[
            "vector<int> $1($2);",
            "REP(i,$2) cin >> $1[i];",
            "$3"
        ],
        "description": "vector<int>の受取"
    },

    "cin_vector_tuple":{
        "prefix": "cvt",
        "body":[
            "vector<T> $1($2);",
            "REP(i,$2){",
            "  int _x,_y,_z;",
            "  cin >> _x >> _y >> _z;",
            "  $1[i] = T(_x,_y,_z);",
            "}",
            "$3",
        ],
        "description": "vector<int>の受取"
    },

    "get_root":{
        "prefix": "gr",
        "body":[
            "int get_root(int p) {",
            "  for(int i=2;i<p;i++) {",
            "    set<int> S;",
            "    int x=1,j;",
            "    while(1) {",
            "      if(S.size()==p-1) return i;",
            "      if(S.count(x)) break;",
            "      S.insert(x);",
            "      x=x*i%p;",
            "    }",
            "  }",
            "  assert(0);",
            "}",
        ],
        "description": "原始根を求める"
    },

    "NTT":{
        "prefix": "ntt",
        "body":[
            "constexpr int bmds(int x){",
            "  if(x==0) return 1012924417;",
            "  if(x==1) return 924844033;",
            "  if(x==2) return 998244353;",
            "  if(x==3) return 897581057;",
            "  if(x==4) return 645922817;",
            "}",
            "constexpr int brts(int x){",
            "  if(x==0) return 5;",
            "  if(x==1) return 5;",
            "  if(x==2) return 3;",
            "  if(x==3) return 3;",
            "  if(x==4) return 3;",
            "}",
            " ",
            "template<int X>",
            "struct NTT{",
            "  static constexpr int md = bmds(X);",
            "  static constexpr int rt = brts(X);",
            " ",
            "  inline int add(int a,int b){",
            "    a+=b;",
            "    if(a>=md) a-=md;",
            "    return a;",
            "  }",
            "  ",
            "  inline int mul(int a,int b){",
            "    return 1LL*a*b%md;",
            "  }",
            "  ",
            "  inline int pow(int a,int b){",
            "    int res=1;",
            "    while(b){",
            "      if(b&1) res=mul(res,a);",
            "      a=mul(a,a);",
            "      b>>=1;",
            "    }",
            "    return res;",
            "  }",
            " ",
            "  inline int inv(int x){",
            "    return pow(x,md-2);",
            "  }",
            "  ",
            "  vector<vector<int> > rts,rrts;",
            "  ",
            "  void ensure_base(int n){",
            "    if((int)rts.size()>=n) return;",
            "    rts.resize(n);rrts.resize(n);",
            "    for(int i=1;i<n;i<<=1){",
            "      if(!rts[i].empty()) continue;",
            "      int w=pow(rt,(md-1)/(i<<1));",
            "      int rw=inv(w);",
            "      rts[i].resize(i);rrts[i].resize(i);",
            "      rts[i][0]=1;rrts[i][0]=1;",
            "      for(int k=1;k<i;k++){",
            "      rts[i][k]=mul(rts[i][k-1],w);",
            "      rrts[i][k]=mul(rrts[i][k-1],rw);",
            "      }",
            "    }",
            "  }",
            " ",
            "  void ntt(vector<int> &a,bool f,int n=-1){",
            "    if(n==-1) n=a.size();",
            "    assert((n&(n-1))==0);",
            "    ",
            "    for(int i=0,j=1;j+1<n;j++){",
            "      for(int k=n>>1;k>(i^=k);k>>=1);",
            "      if(i>j) swap(a[i],a[j]);",
            "    }",
            " ",
            "    for(int i=1;i<n;i<<=1){",
            "      for(int j=0;j<n;j+=i*2){",
            "    for(int k=0;k<i;k++){",
            "    int z=mul(a[i+j+k],f?rrts[i][k]:rts[i][k]);",
            "    a[i+j+k]=add(a[j+k],md-z);",
            "    a[j+k]=add(a[j+k],z);",
            "    }",
            "      }",
            "    }",
            "    ",
            "    if(f){",
            "      int tmp=inv(n);",
            "      for(int i=0;i<n;i++) a[i]=mul(a[i],tmp);",
            "    }",
            "  }",
            " ",
            "  vector<int> multiply(vector<int> &a,vector<int> &b){",
            "    int need=a.size()+b.size()-1;",
            "    int sz=1;",
            "    while(sz<need) sz<<=1;",
            "    ensure_base(sz);",
            "    ",
            "    vector<int> f(sz),g(sz);",
            "    for(int i=0;i<(int)a.size();i++) f[i]=a[i];",
            "    for(int i=0;i<(int)b.size();i++) g[i]=b[i];",
            "    ntt(f,0);ntt(g,0);",
            "    for(int i=0;i<sz;i++) f[i]=mul(f[i],g[i]);",
            "    ntt(f,1);",
            " ",
            "    f.resize(need);",
            "    return f;",
            "  }",
            "  ",
            "};",
            
        ],
        "description": "NTT"
    },

    "mex":{
        "prefix": "mex",
        "body":[
            "template<typename T>",
            "vector<T> compress(vector<T> v){",
            "  sort(v.begin(),v.end());",
            "  v.erase(unique(v.begin(),v.end()),v.end());",
            "  return v;",
            "}",
            "",
            "int mex(vector<int> &a){",
            "  if(!a.size()) return 0;",
            "  vector<int> b = compress(a);",
            "  REP(i,b.size()) if(b[i]!=i) return i;",
            "  return b.size();",
            "}",
            
        ],
        "description": "mex"
    },

    "xor_shift":{
        "prefix": "xorshift",
        "body":[
        "//2^128(U32)の xor shift",
        "unsigned long xor128() {",
        "  static unsigned long x=123456789, y=362436069, z=521288629, w=88675123;",
        "  unsigned long t=(x^(x<<11));",
        "  x=y; y=z; z=w;",
        "  return ( w=(w^(w>>19))^(t^(t>>8)) );",
        "}",
        ],
        "description": "乱数生成"
    },

    "mint":{
        "prefix": "mint",
        "body":[
            "vector<int> MODS = { 1000000007, 998244353 }; // 実行時に決まる",
            "template<int IND = 0> struct Fp {",
            "    long long val;",
            "    ",
            "    int MOD = MODS[IND];",
            "    constexpr Fp(long long v = 0) noexcept : val(v % MODS[IND]) {",
            "        if (val < 0) val += MOD;",
            "    }",
            "    constexpr int getmod() { return MOD; }",
            "    constexpr Fp operator - () const noexcept {",
            "        return val ? MOD - val : 0;",
            "    }",
            "    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }",
            "    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }",
            "    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }",
            "    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }",
            "    constexpr Fp& operator += (const Fp& r) noexcept {",
            "        val += r.val;",
            "        if (val >= MOD) val -= MOD;",
            "        return *this;",
            "    }",
            "    constexpr Fp& operator -= (const Fp& r) noexcept {",
            "        val -= r.val;",
            "        if (val < 0) val += MOD;",
            "        return *this;",
            "    }",
            "    constexpr Fp& operator *= (const Fp& r) noexcept {",
            "        val = val * r.val % MOD;",
            "        return *this;",
            "    }",
            "    constexpr Fp& operator /= (const Fp& r) noexcept {",
            "        long long a = r.val, b = MOD, u = 1, v = 0;",
            "        while (b) {",
            "            long long t = a / b;",
            "            a -= t * b; swap(a, b);",
            "            u -= t * v; swap(u, v);",
            "        }",
            "        val = val * u % MOD;",
            "        if (val < 0) val += MOD;",
            "        return *this;",
            "    }",
            "    constexpr bool operator == (const Fp& r) const noexcept {",
            "        return this->val == r.val;",
            "    }",
            "    constexpr bool operator != (const Fp& r) const noexcept {",
            "        return this->val != r.val;",
            "    }",
            "    friend constexpr ostream& operator << (ostream &os, const Fp<IND>& x) noexcept {",
            "        return os << x.val;",
            "    }",
            "    friend constexpr istream& operator >> (istream &is, Fp<IND>& x) noexcept {",
            "        return is >> x.val;",
            "    }",
            "    friend constexpr Fp<IND> modpow(const Fp<IND> &a, long long n) noexcept {",
            "        if (n == 0) return 1;",
            "        auto t = modpow(a, n / 2);",
            "        t = t * t;",
            "        if (n & 1) t = t * a;",
            "        return t;",
            "    }",
            "};",
            "using mint = Fp<0>; // MODを変える場合は値を変更",
            "typedef vector<mint> vec;",
            "typedef vector<vector<mint>> mat;",
            "vec fact,inv;",
            "void init(int n){",
            "  fact.assign(n+1,1);",
            "  inv.assign(n+1,1);",
            "  REP(i,n) fact[i+1] = fact[i]*(i+1), inv[i+1] /= fact[i+1];",
            "}",
            "",
            "mint cmb(int n, int r){",
            "  if(n < r || r < 0) return 0;",
            "  return fact[n]*inv[r]*inv[n-r];",
            "}",
            
        ],
        "description": "modint"
    },

    "over_flow":{
        "prefix": "reroot",
        "body":[
            "template< typename sum_t, typename key_t >",
            "struct ReRooting {",
            "  struct Edge {",
            "    int to;",
            "    key_t data;",
            "    sum_t dp, ndp;",
            "  };",
            " ",
            "  using F = function< sum_t(sum_t, sum_t) >;",
            "  using G = function< sum_t(sum_t, key_t) >;",
            " ",
            "  vector< vector< Edge > > g;",
            "  vector< sum_t > subdp, dp;",
            "  const sum_t ident;",
            "  const F f;",
            "  const G gg;",
            " ",
            "  ReRooting(int V, const F f, const G g, const sum_t &ident)",
            "      : g(V), f(f), gg(g), ident(ident), subdp(V, ident), dp(V, ident) {}",
            "",
            "  void add_edge(int u, int v, const key_t &d) {",
            "    g[u].emplace_back((Edge) {v, d, ident, ident});",
            "    g[v].emplace_back((Edge) {u, d, ident, ident});",
            "  }",
            "",
            "  void add_edge_bi(int u, int v, const key_t &d, const key_t &e) {",
            "    g[u].emplace_back((Edge) {v, d, ident, ident});",
            "    g[v].emplace_back((Edge) {u, e, ident, ident});",
            "  }",
            " ",
            "  void dfs_sub(int idx, int par) {",
            "    for(auto &e : g[idx]) {",
            "      if(e.to == par) continue;",
            "      dfs_sub(e.to, idx);",
            "      subdp[idx] = f(subdp[idx], gg(subdp[e.to], e.data));",
            "    }",
            "  }",
            " ",
            "  void dfs_all(int idx, int par, const sum_t &top) {",
            "    sum_t buff{ident};",
            "    for(int i = 0; i < (int) g[idx].size(); i++) {",
            "      auto &e = g[idx][i];",
            "      e.ndp = buff;",
            "      e.dp = gg(par == e.to ? top : subdp[e.to], e.data);",
            "      buff = f(buff, e.dp);",
            "    }",
            "    dp[idx] = buff;",
            "    buff = ident;",
            "    for(int i = (int) g[idx].size() - 1; i >= 0; i--) {",
            "      auto &e = g[idx][i];",
            "      if(e.to != par) dfs_all(e.to, idx, f(e.ndp, buff));",
            "      e.ndp = f(e.ndp, buff);",
            "      buff = f(buff, e.dp);",
            "    }",
            "  }",
            " ",
            "  vector< sum_t > build() {",
            "    dfs_sub(0, -1);",
            "    dfs_all(0, -1, ident);",
            "    return dp;",
            "  }",
            "};",            
        ],
        "description": "抽象化全方位木DP"
    },

    "dfs_tree":{
        "prefix": "tree",
        "body":[
            "function<void(int, int)> dfs = [&](int no, int par){",
            "  for(int to: edge[no]){",
            "    if(to==par) continue;",
            "    dfs(to,no);",
            "  }",
            "};",
        ],
        "description": "木DFS"
    },

    "extgcd":{
        "prefix": "ext",
        "body":[
            "int extgcd(int a, int b, int& x, int& y) {",
            "  if (a < b) return extgcd(b, a, y, x);",
            "  if (b > 0) {",
            "    int g = extgcd(b, a % b, y, x);",
            "    y -= (a / b) * x;",
            "    return g;",
            "  } else {",
            "    x = 1, y = 0;",
            "    return a;",
            "  }",
            "}",
        ],
        "description": "拡張ユークリッド互除法"
    },

    "sweeping":{
        "prefix": "hakidasi",
        "body":[
            "int sweeping(vector<int> &a){",
            "  vec V;",
            "  for(int x:a){",
            "    for(int v: V) if(parity(x,MSB(v))) x ^= v;",
            "    if(x > 0){",
            "      for(int& v : V) if(parity(v,MSB(x))) v ^= x;",
            "      V.push_back(x);",
            "      sort(V.rbegin(), V.rend());",
            "    }",
            "  }",
            "  int res = 0;",
            "  for(int v: V) res ^= v;",
            "  return res;",
            "}",
        ],
        "description": "F_2上の掃き出し法"
    },

    "LCA":{
        "prefix": "lca",
        "body":[
            "struct LCA{",
            "  int N;",
            "  vector<int> dist;",
            "  vector<vector<int>> edge,par;",
            "  int MAX_LOG_V;",
            "",
            "  LCA(const vector<vector<int>> &edge) : edge(edge){",
            "    N = edge.size();",
            "    dist.resize(N);",
            "    MAX_LOG_V = log2(N)+1;",
            "    par.resize(MAX_LOG_V);",
            "    REP(i,MAX_LOG_V) par[i].resize(N);",
            "  };",
            "",
            "  void dfs(int no,int p,int d){",
            "    par[0][no]=p;",
            "    dist[no]=d;",
            "    for(auto to:edge[no]){",
            "      if(to!=p) dfs(to,no,d+1);",
            "    }",
            "  }",
            "",
            "  void init(){",
            "    dfs(0,-1,0); //root,parent,dist",
            "    for(int k=0;k+1<MAX_LOG_V;++k){",
            "      for(int v=0;v<N;v++){",
            "        if(par[k][v]<0) par[k+1][v]=-1;",
            "        else par[k+1][v]=par[k][par[k][v]];",
            "      }",
            "    }",
            "  }",
            "",
            "  int get(int u,int v){",
            "    if(dist[u]>dist[v]) swap(u,v);",
            "    for(int k=0;k<MAX_LOG_V;++k){",
            "      if((dist[v]-dist[u])>>k&1){",
            "        v=par[k][v];",
            "      }",
            "    }",
            "    if(u==v) return u;",
            "    for(int k=MAX_LOG_V-1;k>=0;--k){",
            "      if(par[k][u]!=par[k][v]){",
            "        u=par[k][u];",
            "        v=par[k][v];",
            "      }",
            "    }",
            "    return par[0][u];",
            "  }",
            "",
            "  // パス(x,z)上に点yが存在するか",
            "  bool isTrail(int x, int y, int z){",
            "    return dist[x]+dist[z]-dist[get(x,z)]*2 == dist[x]+dist[y]*2+dist[z]-dist[get(x,y)]*2-dist[get(y,z)]*2;",
            "  }",
            "};",
        ],
        "description": "LCA"
    },

    "compress":{
        "prefix": "comp",
        "body":[
            "template<typename T>",
            "vector<T> compress(vector<T> v){",
            "  sort(v.begin(),v.end());",
            "  v.erase(unique(v.begin(),v.end()),v.end());",
            "  return v;",
            "}",
            "",
            "template<typename T>",
            "map<T, int> dict(const vector<T> &v){",
            "  map<T, int> res;",
            "  for(int i=0;i<(int)v.size();i++)",
            "    res[v[i]]=i;",
            "  return res;",
            "}",
        ],
        "description": "座圧"
    },

    "cin_vvector_int":{
        "prefix": "cvvi",
        "body":[
            "vector<vector<int>> $1($2,vector<int>($3));",
            "REP(i,$2) REP(j,$3) cin >> $1[i][j];",
            "$4"
        ],
        "description": "vector<int>の2次元配列の受取"
    },

    "vector_pair":{
        "prefix": "vp",
        "body":[
            "vector<P> $1($2);",
            "$3"
        ],
        "description": "vector<P>"
    },

    "cin_vector_string":{
        "prefix": "cvs",
        "body":[
            "vector<string> $1($2);",
            "REP(i,$2) cin >> $1[i];",
            "$3"
        ],
        "description": "vector<string>の受取"
    },

    "cin_vector_pair":{
        "prefix": "cvp",
        "body":[
            "vector<P> $1($2);",
            "REP(i,$2){",
            "  int x,y;",
            "  cin >> x >> y;",
            "  $1[i] = P(x,y);",
            "}",
            "$3"
        ],
        "description": "vector<string>の受取"
    },

    "cin_vector_graph":{
        "prefix": "cvg",
        "body":[
            "REP(_,$1){",
            "  int x,y;",
            "  cin >> x >> y;",
            "  x--; y--;",
            "  edge[x].emplace_back(y);",
            "  edge[y].emplace_back(x);",
            "}",
        ],
        "description": "重み無し無向グラフの受取"
    },

    "cin_weighted_graph":{
        "prefix": "cwg",
        "body":[
            "Graph $1($2);",
            "REP(_,$3){",
            "  int node_x,node_y,cost = 1;",
            "  cin >> node_x >> node_y;",
            "  cin >> cost;  // 重みなしなら削除",
            "  node_x--; node_y--;",
            "  $1[node_x].pb(P(node_y,cost));",
            "  $1[node_y].pb(P(node_x,cost));",
            "}",
            "$4"
        ],
        "description": "重み付き無向グラフの受取"
    },

    "divisor":{
        "prefix": "divi",
        "body":[
            "vector<int> divisor(const int n){",
            "  vector<int> ret;",
            "  for(int i=1;i*i<=n;i++){",
            "    if(n % i == 0){",
            "      ret.push_back(i);",
            "      if(i*i!= n) ret.push_back(n/i);",
            "    }",
            "  }",
            "  sort(ret.begin(),ret.end());",
            "  return ret;",
            "}"
        ],
        "description": "約数列挙"
    },

    "matpow":{
        "prefix": "matpow",
        "body":[
            "int m;",
            "vec matmul(vec &dp, mat &mt){",
            "  vec ret(m,0);",
            "  REP(i,m) REP(j,m) ret[i] += mt[i][j]*dp[j];",
            "  return ret;",
            "}",
            "",
            "mat update(mat &mt){",
            "  mat ret(m,vec(m,0));",
            "  REP(i,m) REP(j,m) REP(k,m) ret[i][j] += mt[i][k]*mt[k][j];",
            "  return ret;",
            "}",
            "", 
            "void matpow(vec &dp, mat &mt, int k){",
            "  m = dp.size();",
            "  while(k){",
            "    if(k%2) dp = matmul(dp,mt);",
            "    mt = update(mt);",
            "    k /= 2;",
            "  }",
            "}",
        ],
        "description": "行列累乗"
    },

    "BIT":{
        "prefix": "BIT",
        "body":[
            "struct BIT{",
            "private:",
            "  vector<int> bit;",
            "  int num;",
            "",
            "public:",
            "  BIT(vector<int> v){",
            "    num = v.size();",
            "    bit.resize(num);",
            "    REP(i,num) bit[i] = v[i];",
            "  }",
            "",
            "  int sum(int i){",
            "    int s = 0;",
            "    while(i > 0){",
            "      s += bit[i];",
            "      i -= i & -i;",
            "    }",
            "    return s;",
            "  }",
            "",
            "  void add(int i, int x){",
            "    while(i <= num){",
            "      bit[i] += x;",
            "      i += i & -i;",
            "    }",
            "  }",
            "};"
        ],
        "description": "BIT"
    },

    "dijkstra":{
        "prefix": "dijk",
        "body":[
            "template <typename T>",
            "struct dijkstra{",
            "  using E = pair<int,T>;",
            "  int N;",
            "  vector<T> dist;",
            "  vector<vector<E>> edge;",
            "  dijkstra(){};",
            "  dijkstra(int N):N(N){",
            "    dist.assign(N,LINF);",
            "    edge.resize(N);",
            "  }",
            "  void add_edge(int x, int y, T c){",
            "    edge[x].push_back(E(y,c));",
            "  }",
            "  void add_edge2(int x, int y, T c){",
            "    edge[x].push_back(E(y,c));",
            "    edge[y].push_back(E(x,c));",
            "  }",
            "  void build(int s){",
            "    dist[s] = 0;",
            "    priority_queue<E,vector<E>,greater<E>> que;",
            "    que.push(E(0,s));",
            "    while(!que.empty()){",
            "      E p = que.top();",
            "      que.pop();",
            "      int v = p.sc;",
            "      for(E to:edge[v]){",
            "        if(dist[to.fs] > dist[v]+to.sc){",
            "          dist[to.fs] = dist[v]+to.sc;",
            "          que.push(E(dist[to.fs],to.fs));",
            "        }",
            "      }",
            "    }",
            "  }",
            "  T get(int no){",
            "    return dist[no];",
            "  }",
            "};",            
        ],
        "description": "dijkstra"
    },

    "range_dijkstra":{
        "prefix": "rdijk",
        "body":[
            "template <typename T>",
            "struct range_dijkstra{",
            "  int n;",
            "  struct edge { int to; T weight;};",
            "  vector<vector<edge>> g;",
            "  vector<T> dist;",
            "  ",
            "  range_dijkstra(int n) : n(n) {",
            "    g.resize(n<<2);",
            "    for (int i = 1; i < n; ++i) {",
            "      int c1 = i<<1|0, c2 = i<<1|1;",
            "      g[i].push_back({c1, 0});",
            "      g[i].push_back({c2, 0});",
            "      g[c1+2*n].push_back({i+2*n, 0});",
            "      g[c2+2*n].push_back({i+2*n, 0});",
            "    }",
            "    for (int i = n; i < 2*n; ++i) g[i].push_back({i+2*n, 0});",
            "  }",
            "  // from [l1, r1) to [l2, r2)",
            "  void add_edge(int l1, int r1, int l2, int r2, T w) {",
            "    int id = g.size();",
            "    for (l1 += n, r1 += n; l1 < r1; l1 >>= 1, r1 >>= 1) {",
            "      if (l1 & 1) g[l1+2*n].push_back({id, 0}), l1++;",
            "      if (r1 & 1) --r1, g[r1+2*n].push_back({id, 0});",
            "    }",
            "    vector<edge> node;",
            "    for (l2 += n, r2 += n; l2 < r2; l2 >>= 1, r2 >>= 1) {",
            "      if (l2 & 1) node.push_back({l2++, w});",
            "      if (r2 & 1) node.push_back({--r2, w});",
            "    }",
            "    g.push_back(node);",
            "  }",
            "  void add_edge2(int l1, int r1, int l2, int r2, T w) {",
            "    add_edge(l1,r1,l2,r2,w);",
            "    add_edge(l2,r2,l1,r1,w);",
            "  }",
            "  void build(int s) {",
            "    s += n;",
            "    dist.assign(g.size(), LINF);",
            "    dist[s] = 0;",
            "    using E = pair<T , int>;",
            "    priority_queue<E, vector<E>, greater<E>> que;",
            "    que.emplace(0, s);",
            "    while (!que.empty()) {",
            "      E p = que.top();",
            "      que.pop();",
            "      int v = p.second;",
            "      if (dist[v] < p.first) continue;",
            "      for (edge& e : g[v]) {",
            "        if (dist[e.to] > dist[v] + e.weight) {",
            "          dist[e.to] = dist[v] + e.weight;",
            "          que.emplace(dist[e.to], e.to);",
            "        }",
            "      }",
            "    }",
            "  }",
            "  T get(int no){",
            "    return dist[no+n];",
            "  }",
            "};",            
        ],
        "description": "区間dijkstra"
    },

    "z_algorithm":{
        "prefix": "z_algo",
        "body":[
            "//文字列Sと、Sのi文字目からの文字列Tの最長一致の接頭辞長",
            "vector<int> z_algorithm(string& s){",
            "  int n = s.size(), c = 0;",
            "  vec ret(n);",
            "  FOR(i,1,n){",
            "    if(i+ret[i-c] < c + ret[c]) ret[i] = ret[i-c];",
            "    else{",
            "      int j = max(0LL,c+ret[c]-i);",
            "      while(i+j < n && s[j] == s[i+j]) j++;",
            "      ret[i] = j;",
            "      c = i;",
            "    }",
            "  }",
            "  ret[0] = n;",
            "  return ret;",
            "}",
        ],
        "description": "Zアルゴリズム"
    },

    "manacher":{
        "prefix": "manacher",
        "body":[
            "//文字列Sのi文字目を中心とした回文半径",
            "vector<int> manacher(string &S){",
            "  vector<int> R;",
            "  R.resize(S.size());",
            "  int i = 0, j = 0;",
            "  while (i < S.size()){",
            "    while (i-j >= 0 && i+j < S.size() && S[i-j] == S[i+j]) ++j;",
            "    R[i] = j;",
            "    int k = 1;",
            "    while (i-k >= 0 && i+k < S.size() && k+R[i-k] < j) R[i+k] = R[i-k], ++k;",
            "    i += k; j -= k;",
            "  }",
            "  return R;",
            "}",
        ],
        "description": "manacher"
    },

    "FFT":{
        "prefix": "FFT",
        "body":[
            "typedef complex<double> C;",
            "int fft_n;",
            "vector<C> omega;",
            "const double PI=3.14159265358979323846;",
            "",
            "void init_fft(int n) {",
            "  fft_n = n;",
            "  omega.resize(n);",
            "  double angle = 2 * PI / n;",
            "  REP(i,n) {",
            "    omega[i] = C(cos(i * angle), sin(i * angle));",
            "  }",
            "}",
            "",
            "void fft(vector<C> & a) {",
            "  int n = a.size();",
            "  if (n == 1) return;",
            "  int half = n >> 1;",
            "  vector<C> even(half), odd(half);",
            "  for (int i = 0, j = 0; i < n; i += 2, ++j) {",
            "    even[j] = a[i];",
            "    odd[j] = a[i+1];",
            "  }",
            "  fft(even); fft(odd);",
            "  for (int i = 0, fact = fft_n / n; i < half; ++i) {",
            "    C twiddle = odd[i] * omega[i * fact];",
            "    a[i] = even[i] + twiddle;",
            "    a[i + half] = even[i] - twiddle;",
            "  }",
            "}",
            "",
            "vector<int> mul_fft(const vector<int> &a, const vector<int> &b) {",
            "  vector<int> res;",
            "  vector<C> fa(a.begin(), a.end()), fb(b.begin(), b.end());",
            "  int n = 1;",
            "  while (n < 2 * max (a.size(), b.size())) n <<= 1;",
            "  fa.resize(n); fb.resize(n);",
            "  init_fft(n);",
            "  fft(fa); fft(fb);",
            "  REP(i,n) fa[i] = conj(fa[i] * fb[i]);",
            "  fft(fa);",
            "  res.resize (n);",
            "  REP(i,n) {",
            "    res[i] = (int) (fa[i].real() / n + 0.5);",
            "  }",
            "  return res;",
            "}",
            "// vec hoge = mul_fft(a,b)で呼び出し",
            "// hoge[i]はΣa[k]*b[i-k]",
            "// a,bは1-indexedで取る(0があれば0に)",
        ],
        "description": "高速フーリエ変換"
    },

    "ALL":{
        "prefix": "all",
        "body":[
            "$1.begin(),$1.end()",
        ],
        "description": "全選択"
    },

    "RALL":{
        "prefix": "rall",
        "body":[
            "$1.rbegin(),$1.rend()",
        ],
        "description": "逆順全選択"
    },

    "EulerianTrail":{
        "prefix": "euler",
        "body":[
            "void make_trail(int no, vector<int> &trail) {",
            "  while(edge[no].size()) {",
            "    int v = edge[no].back();",
            "    edge[no].pop_back();",
            "    for (int to = 0; i < edge[v].size();++i) {",
            "      if (edge[v][i] == no) {",
            "        edge[v].erase(edge[v].begin() + i);",
            "        break;",
            "      }",
            "    }",
            "    make_trail(v, trail);",
            "  }",
            "  trail.push_back(no);",
            "}",
            "",  
            "vector<int> EulerianTrail(const int s){",
            "  vector<int> res;",
            "  make_trail(s,res);",
            "  reverse(res.begin(),res.end());",
            "  return res;",
            "}",
        ],
        "description": "オイラー路構築"
    },

    "next_index":{
        "prefix": "nxid",
        "body":[
                "//文字列Sのi文字目以降初めてアルファベットjが出現するindex。O(|S|*文字種)",
                "mat next_index(string &s){",
                "  int len = s.size();",
                "  mat nx(len,vec(26,LINF));",
                "  REP(i,len) nx[i][s[i]-'a'] = i+1;",
                "  RREP(i,len-1) REP(j,26) nx[i][j] = min(nx[i][j],nx[i+1][j]);",
                "  return nx;",
                "}",
                
        ],
        "description": "文字列内で次に文字が出現するindex前計算"
    },

    "bfs":{
        "prefix": "bfs",
        "body":[
            "vector<vector<int>> bfs(vector<string> &s){",
            "  int h = s.size(), w = s[0].size();",
            "  vector<vector<int>> tmp(h,vec(w,-1));",
            "  queue<P> que;",
            "  // ↓ここにqueの初期化操作を書く",
            "",
            "  vector<int> dx = {1,-1,0,0,1,1,-1,-1}, dy = {0,0,1,-1,1,-1,1,-1};",
            "  while(que.size()){",
            "    P p = que.front(); que.pop();",
            "      REP(i,dx.size()){",
            "        int x = p.fs+dx[i], y = p.sc+dy[i];",
            "        if(range(x,0,h) && range(y,0,w) && tmp[x][y] == -1){",
            "          tmp[x][y] = tmp[p.fs][p.sc]+1;",
            "          que.push(P(x,y));",
            "        }",
            "      }",
            "    }",
            "  return tmp;",
            "}",
        ],
        "description": "bfs"
    },

    "CHT":{
        "prefix": "cht",
        "body":[
            "template <typename T,T inf,bool isMin>",
            "struct ConvexHullTrick {",
            "  using P = pair<T, T>;",
            "  deque<P> L;",
            " ",
            "  inline T getY(const P &a,const T &x){",
            "    return a.first*x+a.second; ",
            "  }",
            " ",
            "  inline bool check(const P &a,const P &b,const P &c){",
            "    return (b.first-a.first)*(c.second-b.second)",
            "      >= (b.second-a.second)*(c.first-b.first);",
            "  }",
            "  ",
            "  void add(T a,T b){",
            "    if(!isMin) a*=-1,b*=-1;",
            "    P line(a,b);",
            "    if(!L.empty()&&L.back().first==a){",
            "      line.second=min(line.second,L.back().second);",
            "      L.pop_back();",
            "    }",
            "    while(L.size()>=2&&check(L[L.size()-2],L[L.size()-1],line)) L.pop_back();",
            "    L.emplace_back(line);    ",
            "  }",
            " ",
            "  T get(T x){",
            "    if(L.empty()) return isMin?inf:-inf;",
            "    int low=-1,high=L.size()-1;",
            "    while(low+1<high){",
            "      int mid=(low+high)>>1;",
            "      if(getY(L[mid],x)>=getY(L[mid+1],x)) low=mid;",
            "      else high=mid;",
            "    }",
            "    return (!isMin?-1:1)*getY(L[high],x);",
            "  }",
            "  ",
            "  T getMonotone(T x){",
            "    if(L.empty()) return isMin?inf:-inf;",
            "    while(L.size()>=2&&getY(L[0],x)>=getY(L[1],x)) L.pop_front();",
            "    return (!isMin?-1:1)*getY(L[0],x);",
            "  }",
            "};",            
        ],
        "description": "cht"
    },

    "trie":{
        "prefix": "trie",
        "body":[
            "template<size_t X>",
            "struct Trie{",
            "  struct Node{",
            "    char c;",
            "    array<int, X> nxt;",
            "    vector<int> idxs,edge;",
            "    int idx, cnt = 0;",
            "    Node(char c):c(c),idx(-1){fill(nxt.begin(),nxt.end(),-1);}",
            "  };",
            "",
            "  using F = function<int(char)>;",
            "  vector<Node> vs;",
            "  F conv;",
            "",
            "  Trie(F conv,char c='$'):conv(conv){vs.emplace_back(c);}",
            "",
            "  inline int &next(int i,int j){",
            "    return vs[i].nxt[j];",
            "  }",
            "",
            "  void add(const string &s,int x){",
            "    int pos=0;",
            "    for(int i=0;i<(int)s.size();i++){",
            "      int k=conv(s[i]);",
            "      if(~next(pos,k)){",
            "        pos=next(pos,k);",
            "        continue;",
            "      }",
            "      int npos=vs.size();",
            "      next(pos,k)=npos;",
            "      vs[pos].edge.emplace_back(npos);",
            "      vs.emplace_back(s[i]);",
            "      pos=npos;",
            "    }",
            "    vs[pos].idx=x;",
            "    vs[pos].cnt++;",
            "    vs[pos].idxs.emplace_back(x);",
            "  }",
            "",
            "  int find(const string &s){",
            "    int pos=0;",
            "    for(int i=0;i<(int)s.size();i++){",
            "      int k=conv(s[i]);",
            "      if(next(pos,k)<0) return -1;",
            "      pos=next(pos,k);",
            "    }",
            "    return pos;",
            "  }",
            "",
            "  int move(int pos,char c){",
            "    assert(pos<(int)vs.size());",
            "    return pos<0?-1:next(pos,conv(c));",
            "  }",
            "",
            "  int size(){return vs.size();}",
            "",
            "  int idx(int pos){",
            "    return pos<0?-1:vs[pos].idx;",
            "  }",
            "",
            "  vector<int> idxs(int pos){",
            "    return pos<0?vector<int>():vs[pos].idxs;",
            "  }",
            "};",            
        ],
        "description": "Trie木"
    },

    "sum":{
        "prefix": "sum",
        "body":[
            "//半開区間",
            "int sum(int x, int y, int s, int t, vector<vector<int>> &tmp){",
            "  return tmp[s][t]-tmp[s][y]-tmp[x][t]+tmp[x][y];",
            "}"
        ],
        "description": "二次元累積和の総和"
    },

    "HLDecomposition":{
        "prefix": "HLD",
        "body":[
            "struct HLDecomposition {",
            "  int n,pos;",
            "  vector<vector<int> > G;",
            "  vector<int> vid, head, sub, par, dep, inv, type;",
            "  ",
            "  HLDecomposition(){}",
            "  HLDecomposition(int n):",
            "    n(n),pos(0),G(n),vid(n,-1),head(n),sub(n,1),",
            "    par(n,-1),dep(n,0),inv(n),type(n){}",
            "  ",
            "  void add_edge(int u, int v) {",
            "    G[u].push_back(v);",
            "    G[v].push_back(u);",
            "  }",
            " ",
            "  void build(vector<int> rs={0}) {",
            "    int c=0;",
            "    for(int r:rs){",
            "      dfs_sz(r);",
            "      head[r]=r;",
            "      dfs_hld(r,c++);",
            "    }",
            "  }",
            "  ",
            "  void dfs_sz(int v) {",
            "    for(int &u:G[v]){",
            "      if(u==par[v]) continue;",
            "      par[u]=v;",
            "      dep[u]=dep[v]+1;",
            "      dfs_sz(u);      ",
            "      sub[v]+=sub[u];      ",
            "      if(sub[u]>sub[G[v][0]]) swap(u,G[v][0]);",
            "    }",
            "  }",
            " ",
            "  void dfs_hld(int v,int c) {",
            "    vid[v]=pos++;",
            "    inv[vid[v]]=v;",
            "    type[v]=c;",
            "    for(int u:G[v]){",
            "      if(u==par[v]) continue;",
            "      head[u]=(u==G[v][0]?head[v]:u);",
            "      dfs_hld(u,c);",
            "    }    ",
            "  }",
            "  ",
            "  // for_each(vertex)",
            "  // [l,r] <- attention!!  ",
            "  template<typename F>",
            "  void for_each(int u, int v, const F& f) {",
            "    while(1){",
            "      if(vid[u]>vid[v]) swap(u,v);",
            "      f(max(vid[head[v]],vid[u]),vid[v]);",
            "      if(head[u]!=head[v]) v=par[head[v]];",
            "      else break;",
            "    }",
            "  }",
            " ",
            "  template<typename T,typename Q,typename F>",
            "  T for_each(int u,int v,T ti,const Q &q,const F &f){",
            "    T l=ti,r=ti;",
            "    while(1){",
            "      if(vid[u]>vid[v]){",
            "        swap(u,v);",
            "        swap(l,r);",
            "      }",
            "      l=f(l,q(max(vid[head[v]],vid[u]),vid[v]));",
            "      if(head[u]!=head[v]) v=par[head[v]];",
            "      else break;",
            "    }",
            "    return f(l,r);",
            "  }",
            "  ",
            "  // for_each(edge)",
            "  // [l,r] <- attention!!",
            "  template<typename F>",
            "  void for_each_edge(int u, int v,const F& f) {",
            "    while(1){",
            "      if(vid[u]>vid[v]) swap(u,v);",
            "      if(head[u]!=head[v]){",
            "        f(vid[head[v]],vid[v]);",
            "        v=par[head[v]];",
            "      }else{",
            "        if(u!=v) f(vid[u]+1,vid[v]);",
            "        break;",
            "      }",
            "    }",
            "  }",
            "  ",
            "  int lca(int u,int v){",
            "    while(1){",
            "      if(vid[u]>vid[v]) swap(u,v);",
            "      if(head[u]==head[v]) return u;",
            "      v=par[head[v]];",
            "    }",
            "  }",
            " ",
            "  int distance(int u,int v){",
            "    return dep[u]+dep[v]-2*dep[lca(u,v)];",
            "  }",
            "};",
        ],
        "description": "HL分解"
    },

    "KMP":{
        "prefix": "kmp",
        "body":[
            "template < class T >",
            "vector< int > KMP(T s) {",
            "  int n = s.size();",
            "  vector< int > kmp(n + 1), mp(n + 1), res(n);",
            "  kmp[0] = mp[0] = -1;",
            "  int j = -1;",
            "  for(int i = 0; i < n; i++) {",
            "    while(j >= 0 && s[i] != s[j]) j = kmp[j];",
            "    kmp[i + 1] = mp[i + 1] = ++j;",
            "    if(i + 1 < n && s[i + 1] == s[j]) kmp[i + 1] = kmp[j];",
            "  }",
            "  for(int i = 0; i < n; i++) res[i] = mp[i+1];",
            "  return res;",
            "}",            
        ],
        "description": "KMP"
    },

    "inversion":{
        "prefix": "inversion",
        "body":[
            "int inversion(vector<int> &A, const int l, const int r, vector<int> &T) {",
            "  if(r <= l+1) return 0;",
            "  int cnt = 0;",
            "  const int m = (l+r)/2;",
            "  cnt += inversion(A,l,m,T) + inversion(A,m,r,T);",
            "",
            "  int i = l, j = m, k = 0, c = 0;",
            "  while(i < m && j < r){",
            "    if(A[j] < A[i]) { // 等しい値も転倒数に含む場合は A[j] <= A[i] とする",
            "      T[k++] = A[j++];",
            "      c++;",
            "    }",
            "    else{",
            "      T[k++] = A[i++];",
            "      cnt += c;",
            "    }",
            "  }",
            "",
            "  while(i < m){",
            "    T[k++] = A[i++];",
            "      cnt += c;",
            "  }",
            "",
            "  while(j < r) T[k++] = A[j++];",
            "",
            "  for(int t = l; t < r; ++t) A[t] = T[t-l];",
            "",
            "  return cnt;",
            "}",
            "",
            "int inversion(vector<int> &A, const int l, const int r) {",
            "  vector<int> T(A.size(),0);",
            "  return inversion(A,l,r,T);",
            "}",
        ],
        "description": "転倒数"
    },

    "PartitionNumber":{
        "prefix": "part",
        "body":[
            "// pn.R(i,j) でi個をjグループで割り振る場合の数。 O(N^2)",
            "template<typename T> struct PartitionNumber{",
            "  int n;",
            "  vector<T> _P; vector<vector<T>> _PP, _Q, _R;",
            "  PartitionNumber(int _n){",
            "    n = _n;",
            "    _P.resize(n + 1);",
            "    _PP.resize(n + 1, vector<T>(n + 1));",
            "    _Q.resize(n + 1, vector<T>(n + 1));",
            "    _R.resize(n + 1, vector<T>(n + 1));",
            "",
            "    _Q[0][0] = 1;",
            "    FOR(i, 1, n + 1) FOR(j, 1, n + 1) {",
            "      _Q[i][j] += _Q[i - 1][j - 1];",
            "      if (j <= i) _Q[i][j] += _Q[i - j][j];",
            "      _Q[i][j] %= MOD;",
            "    }",
            "    FOR(i, 0, n + 1){",
            "      _R[i][0] = _Q[i][0];",
            "      FOR(j, 1, n + 1) _R[i][j] = _R[i][j - 1] + _Q[i][j];",
            "    }",
            "  }",
            "",
            "  int R(int i, int j){",
            "    assert(0 <= j and 0 <= i and j <= n and i <= n);",
            "    return _R[i][j] % MOD;",
            "  }",
            "};",
            "PartitionNumber<int> pn(1010);",
        ],
        "description": "分割数"
    },

    "unionfind":{
        "prefix": "uf",
        "body":[
            "struct UnionFind {",
            "  private:",
            "  vector<int> par,sz;",
            "  vector<tuple<int,int,int>> memo;",
            "  vector<vector<int>> list;",
            " ",
            "public:",
            "  UnionFind(int v) {",
            "    par.resize(v);",
            "    sz.resize(v);",
            "    REP(i,v){",
            "      par[i] = i;",
            "      sz[i] = 1;",
            "    }",
            "  }",
            " ",
            "  int root(int no){",
            "    if(par[no]==no) return no;",
            "    else return root(par[no]);",
            "  }",
            " ",
            "  int size(int i){",
            "    return sz[i];",
            "  }",
            "",
            "  vector<int> nodes(int no){",
            "    assert(false); // undoとの併用禁止",
            "    return list[root(no)];",
            "  }",
            " ",
            "  bool unit(int x, int y){",
            "    x = root(x);",
            "    y = root(y);",
            "    if(x==y) return false;",
            "    if(sz[x] < sz[y]) swap(x,y);",
            "    memo.emplace_back(x,y,par[y]);",
            "    // for(int no:list[y]) list[x].emplace_back(no);",
            "    sz[x] += sz[y];",
            "    par[y] = x;",
            "    return true;",
            "  }",
            " ",
            "  bool same(int x, int y){",
            "    return root(x)==root(y);",
            "  }",
            " ",
            "  bool undo(int t = -1){",
            "    if(memo.empty()) return false;",
            "    if(t==-1) t = memo.size()-1;",
            "    while(memo.size() > t){",
            "      int x,y,v;",
            "      tie(x,y,v) = memo.back();",
            "      memo.pop_back();",
            "      sz[x] -= sz[y];",
            "      par[y] = v;",
            "    }",
            "    return true;",
            "  }",
            "",
            "  int time(){",
            "    return memo.size();",
            "  }",
            "};",
            
        ],
        "description": "unionfind"
    },

    "部分永続unionfind":{
        "prefix": "UF",
        "body":[
            "class PartiallyPersistentUnionFindTree {",
            "public:",
            "  using size_type = std::uint_fast32_t;",
            " ",
            "private:",
            "  std::vector<std::pair<size_type, size_type>> tree;",
            "  std::vector<std::vector<std::pair<size_type, size_type>>> siz;",
            "  size_type global_count;",
            " ",
            "public:",
            "  PartiallyPersistentUnionFindTree(const size_type size)",
            "    : tree(size, std::make_pair(1, std::numeric_limits<size_type>::max())),",
            "      siz(size, std::vector<std::pair<size_type, size_type>>(",
            "      1, std::make_pair(0, 1))),",
            "    global_count(0) {}",
            "  size_type find(const size_type ver, size_type x) const {",
            "    assert(x < tree.size());",
            "    while (tree[x].second <= ver)",
            "      x = tree[x].first;",
            "    return x;",
            "  }",
            "  bool unit(size_type x, size_type y) {",
            "    assert(x < tree.size());",
            "    assert(y < tree.size());",
            "    ++global_count;",
            "    x = find(global_count, x);",
            "    y = find(global_count, y);",
            "    if (x == y)",
            "      return false;",
            "    if (tree[x].first < tree[y].first)",
            "      std::swap(x, y);",
            "    tree[x].first += tree[y].first;",
            "    siz[x].emplace_back(global_count, tree[x].first);",
            "    tree[y] = std::make_pair(x, global_count);",
            "    return true;",
            "  }",
            "  bool isUnit(const size_type ver, const size_type x, const size_type y) const {",
            "    assert(x < tree.size());",
            "    assert(y < tree.size());",
            "    return find(ver, x) == find(ver, y);",
            "  }",
            "  size_type size(const size_type ver, size_type x) const {",
            "    assert(x < tree.size());",
            "    x = find(ver, x);",
            "    return (std::lower_bound(siz[x].begin(), siz[x].end(),",
            "      std::make_pair(ver+1, static_cast<size_type>(0)))-1)",
            "      ->second;",
            "  }",
            "",
            "  size_type count() const { return global_count; }",
            "  size_type query(const size_type ver, size_type x, size_type y)const {",
            "    x = find(ver, x);",
            "    y = find(ver, y);",
            "    if (x == y) return size(ver, x);",
            "    return size(ver, x) + size(ver, y);",
            "  }",
            "};",
            "/*",
            "使い方",
            "宣言: PartiallyPersistentUnionFindTree uf(n);",
            "各クエリ　isUnit(ver,x,y) ver回目のunitでのx,yの連結判定",
            "*/",
        ],
        "description": "部分永続unionfind"
    },

    "prime":{
        "prefix": "prime",
        "body":[
            "for(int i=2;i<n;i+=2){",
            "  bool flag = true;",
            "    for(int j=3; j<=sqrt(i);j+=2){",
            "      if(i%j == 0){",
            "      flag = false;",
            "      break;",
            "    }",
            "  }",
            "  if(flag || i == 2) //素数についての操作//",
            "  if(i == 2) i--;",
            "}"
        ],
        "description": "素数判定"
    },

    "min_cost_flow":{
        "prefix": "min_cost_flow",
        "body":[
            "template <class Cap, class Cost> struct min_cost_flow {",
            "  public:",
            "    min_cost_flow() {}",
            "    min_cost_flow(int n) : _n(n), g(n) {}",
            "",
            "    int add_edge(int from, int to, Cap cap, Cost cost) {",
            "        assert(0 <= from && from < _n);",
            "        assert(0 <= to && to < _n);",
            "        int m = pos.size();",
            "        pos.push_back({from, g[from].size()});",
            "        g[from].push_back(_edge{to, g[to].size(), cap, cost});",
            "        g[to].push_back(_edge{from, g[from].size() - 1, 0, -cost});",
            "        return m;",
            "    }",
            "",
            "    struct edge {",
            "        int from, to;",
            "        Cap cap, flow;",
            "        Cost cost;",
            "    };",
            "",
            "    edge get_edge(int i) {",
            "        int m = pos.size();",
            "        assert(0 <= i && i < m);",
            "        auto _e = g[pos[i].first][pos[i].second];",
            "        auto _re = g[_e.to][_e.rev];",
            "        return edge{",
            "            pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,",
            "        };",
            "    }",
            "    std::vector<edge> edges() {",
            "        int m = pos.size();",
            "        std::vector<edge> result(m);",
            "        for (int i = 0; i < m; i++) {",
            "            result[i] = get_edge(i);",
            "        }",
            "        return result;",
            "    }",
            "",
            "    std::pair<Cap, Cost> flow(int s, int t) {",
            "        return flow(s, t, std::numeric_limits<Cap>::max());",
            "    }",
            "    std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {",
            "        return slope(s, t, flow_limit).back();",
            "    }",
            "    std::vector<std::pair<Cap, Cost>> slope(int s, int t) {",
            "        return slope(s, t, std::numeric_limits<Cap>::max());",
            "    }",
            "    std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {",
            "        assert(0 <= s && s < _n);",
            "        assert(0 <= t && t < _n);",
            "        assert(s != t);",
            "        // variants (C = maxcost):",
            "        // -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0",
            "        // reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge",
            "        std::vector<Cost> dual(_n, 0), dist(_n);",
            "        std::vector<int> pv(_n), pe(_n);",
            "        std::vector<bool> vis(_n);",
            "        auto dual_ref = [&]() {",
            "            std::fill(dist.begin(), dist.end(),",
            "                      std::numeric_limits<Cost>::max());",
            "            std::fill(pv.begin(), pv.end(), -1);",
            "            std::fill(pe.begin(), pe.end(), -1);",
            "            std::fill(vis.begin(), vis.end(), false);",
            "            struct Q {",
            "                Cost key;",
            "                int to;",
            "                bool operator<(Q r) const { return key > r.key; }",
            "            };",
            "            std::priority_queue<Q> que;",
            "            dist[s] = 0;",
            "            que.push(Q{0, s});",
            "            while (!que.empty()) {",
            "                int v = que.top().to;",
            "                que.pop();",
            "                if (vis[v]) continue;",
            "                vis[v] = true;",
            "                if (v == t) break;",
            "                // dist[v] = shortest(s, v) + dual[s] - dual[v]",
            "                // dist[v] >= 0 (all reduced cost are positive)",
            "                // dist[v] <= (n-1)C",
            "                for (int i = 0; i < g[v].size(); i++) {",
            "                    auto e = g[v][i];",
            "                    if (vis[e.to] || !e.cap) continue;",
            "                    // |-dual[e.to] + dual[v]| <= (n-1)C",
            "                    // cost <= C - -(n-1)C + 0 = nC",
            "                    Cost cost = e.cost - dual[e.to] + dual[v];",
            "                    if (dist[e.to] - dist[v] > cost) {",
            "                        dist[e.to] = dist[v] + cost;",
            "                        pv[e.to] = v;",
            "                        pe[e.to] = i;",
            "                        que.push(Q{dist[e.to], e.to});",
            "                    }",
            "                }",
            "            }",
            "            if (!vis[t]) {",
            "                return false;",
            "            }",
            "",
            "            for (int v = 0; v < _n; v++) {",
            "                if (!vis[v]) continue;",
            "                // dual[v] = dual[v] - dist[t] + dist[v]",
            "                //         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) + (shortest(s, v) + dual[s] - dual[v])",
            "                //         = - shortest(s, t) + dual[t] + shortest(s, v)",
            "                //         = shortest(s, v) - shortest(s, t) >= 0 - (n-1)C",
            "                dual[v] -= dist[t] - dist[v];",
            "            }",
            "            return true;",
            "        };",
            "        Cap flow = 0;",
            "        Cost cost = 0, prev_cost = -1;",
            "        std::vector<std::pair<Cap, Cost>> result;",
            "        result.push_back({flow, cost});",
            "        while (flow < flow_limit) {",
            "            if (!dual_ref()) break;",
            "            Cap c = flow_limit - flow;",
            "            for (int v = t; v != s; v = pv[v]) {",
            "                c = std::min(c, g[pv[v]][pe[v]].cap);",
            "            }",
            "            for (int v = t; v != s; v = pv[v]) {",
            "                auto& e = g[pv[v]][pe[v]];",
            "                e.cap -= c;",
            "                g[v][e.rev].cap += c;",
            "            }",
            "            Cost d = -dual[s];",
            "            flow += c;",
            "            cost += c * d;",
            "            if (prev_cost == d) {",
            "                result.pop_back();",
            "            }",
            "            result.push_back({flow, cost});",
            "            prev_cost = cost;",
            "        }",
            "        return result;",
            "    }",
            "",
            "  private:",
            "    int _n;",
            "",
            "    struct _edge {",
            "        int to, rev;",
            "        Cap cap;",
            "        Cost cost;",
            "    };",
            "",
            "    std::vector<std::pair<int, int>> pos;",
            "    std::vector<std::vector<_edge>> g;",
            "};",            
        ],
        "description": "最小費用流"
    },

    "max_flow":{
        "prefix": "maxflow",
        "body":[
            "template <class Cap> struct max_flow {",
            "  public:",
            "    max_flow() : _n(0) {}",
            "    max_flow(int n) : _n(n), g(n) {}",
            "",
            "    int add_edge(int from, int to, Cap cap) {",
            "        assert(0 <= from && from < _n);",
            "        assert(0 <= to && to < _n);",
            "        assert(0 <= cap);",
            "        int m = pos.size();",
            "        pos.push_back({from, g[from].size()});",
            "        g[from].push_back(_edge{to, g[to].size(), cap});",
            "        g[to].push_back(_edge{from, g[from].size() - 1, 0});",
            "        return m;",
            "    }",
            "",
            "    struct edge {",
            "        int from, to;",
            "        Cap cap, flow;",
            "    };",
            "",
            "    edge get_edge(int i) {",
            "        int m = pos.size();",
            "        assert(0 <= i && i < m);",
            "        auto _e = g[pos[i].first][pos[i].second];",
            "        auto _re = g[_e.to][_e.rev];",
            "        return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};",
            "    }",
            "    std::vector<edge> edges() {",
            "        int m = pos.size();",
            "        std::vector<edge> result;",
            "        for (int i = 0; i < m; i++) {",
            "            result.push_back(get_edge(i));",
            "        }",
            "        return result;",
            "    }",
            "    void change_edge(int i, Cap new_cap, Cap new_flow) {",
            "        int m = pos.size();",
            "        assert(0 <= i && i < m);",
            "        assert(0 <= new_flow && new_flow <= new_cap);",
            "        auto& _e = g[pos[i].first][pos[i].second];",
            "        auto& _re = g[_e.to][_e.rev];",
            "        _e.cap = new_cap - new_flow;",
            "        _re.cap = new_flow;",
            "    }",
            "",
            "    Cap flow(int s, int t) {",
            "        return flow(s, t, std::numeric_limits<Cap>::max());",
            "    }",
            "    Cap flow(int s, int t, Cap flow_limit) {",
            "        assert(0 <= s && s < _n);",
            "        assert(0 <= t && t < _n);",
            "",
            "        std::vector<int> level(_n), iter(_n);",
            "        queue<int> que;",
            "",
            "        auto bfs = [&]() {",
            "            std::fill(level.begin(), level.end(), -1);",
            "            level[s] = 0;",
            "            queue<int>().swap(que);",
            "            que.push(s);",
            "            while (!que.empty()) {",
            "                int v = que.front();",
            "                que.pop();",
            "                for (auto e : g[v]) {",
            "                    if (e.cap == 0 || level[e.to] >= 0) continue;",
            "                    level[e.to] = level[v] + 1;",
            "                    if (e.to == t) return;",
            "                    que.push(e.to);",
            "                }",
            "            }",
            "        };",
            "        auto dfs = [&](auto self, int v, Cap up) {",
            "            if (v == s) return up;",
            "            Cap res = 0;",
            "            int level_v = level[v];",
            "            for (int& i = iter[v]; i < g[v].size(); i++) {",
            "                _edge& e = g[v][i];",
            "                if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;",
            "                Cap d =",
            "                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));",
            "                if (d <= 0) continue;",
            "                g[v][i].cap += d;",
            "                g[e.to][e.rev].cap -= d;",
            "                res += d;",
            "                if (res == up) break;",
            "            }",
            "            return res;",
            "        };",
            "",
            "        Cap flow = 0;",
            "        while (flow < flow_limit) {",
            "            bfs();",
            "            if (level[t] == -1) break;",
            "            std::fill(iter.begin(), iter.end(), 0);",
            "            while (flow < flow_limit) {",
            "                Cap f = dfs(dfs, t, flow_limit - flow);",
            "                if (!f) break;",
            "                flow += f;",
            "            }",
            "        }",
            "        return flow;",
            "    }",
            "",
            "    std::vector<bool> min_cut(int s) {",
            "        std::vector<bool> visited(_n);",
            "        queue<int> que;",
            "        que.push(s);",
            "        while (!que.empty()) {",
            "            int p = que.front();",
            "            que.pop();",
            "            visited[p] = true;",
            "            for (auto e : g[p]) {",
            "                if (e.cap && !visited[e.to]) {",
            "                    visited[e.to] = true;",
            "                    que.push(e.to);",
            "                }",
            "            }",
            "        }",
            "        return visited;",
            "    }",
            "",
            "  private:",
            "    int _n;",
            "    struct _edge {",
            "        int to, rev;",
            "        Cap cap;",
            "    };",
            "    std::vector<std::pair<int, int>> pos;",
            "    std::vector<std::vector<_edge>> g;",
            "};",            
        ],
        "description": "最大流"
    },

    "isBip":{
        "prefix": "isBip",
        "body":[
            "const int N = 1e5+10;",
            "vector<int> edge[N],color(N,0);",
            "",
            "bool isBip(int no){",
            "  if(!color[no]) color[no] = 1;",
            "  bool flag = true;",
            "  for(auto to:edge[no]){",
            "    if(color[no]==color[to]) flag = false;",
            "    else if(!color[to]){",
            "      color[to] = -color[no];",
            "      if(!isBip(to)) flag = false;",
            "    }",
            "  }",
            "  return flag;",
            "}",
            // 0の色を指定する！！（１か-１）
        ],
        "description": "2部グラフ判定"
    },

    "bipartite_matching":{
        "prefix": "bipartite_matching",
        "body":[
            "const int MAX_V = 3e5;",
            "int V;",
            "vector<int> G[MAX_V],match,used(MAX_V,0);",
            "",
            "void add_edge(int u, int v){",
            "  G[u].pb(v);",
            "  G[v].pb(u);",
            "}",
            "",
            "bool dfs(int v){",
            "  used[v]++;",
            "  REP(i,G[v].size()){",
            "    int u = G[v][i], w = match[u];",
            "    if(w < 0 || !used[w] && dfs(w)){",
            "      match[v] = u;",
            "      match[u] = v;",
            "      return true;",
            "      }",
            "    }",
            "  return false;",
            "}",
            "",
            "int bipartite_matching(){",
            "  int res = 0;",
            "  match.assign(V,-1);",
            "  REP(s,V){",
            "    if(match[s] < 0){",
            "      used.assign(V,0);",
            "      if(dfs(s)) res++;",
            "      }",
            "    }",
            "  return res;",
            "}",
            "// Vを頂点数に更新する！！"
        ],
        "description": "2部マッチング"
    },

    "t_sort":{
        "prefix": "t_sort",
        "body":[
            "struct t_sort{",
            "  private:",
            "  vector<int> h,ord,inv;",
            "  vector<vector<int>> g;",
            "  int v,e = 0;",
            "",
            "public:",
            "  t_sort(int N){",
            "    h.assign(N,0);",
            "    g.resize(N);",
            "    inv.resize(N);",
            "    v = N;",
            "  }",
            "",
            "  void add_edge(int x, int y){",
            "    g[x].push_back(y);",
            "    h[y]++; e++;    ",
            "  }",
            "",
            "  void build(){",
            "    stack<int> st;",
            "    REP(i, v) if(h[i] == 0) st.push(i);",
            "    while(st.size()) {",
            "      int i = st.top(); st.pop();",
            "      ord.push_back(i);",
            "      for(auto& j: g[i]) {",
            "        h[j]--;",
            "        if(h[j] == 0) st.push(j);",
            "      }",
            "    }",
            "    REP(i,ord.size()) inv[ord[i]] = i;",
            "  }",
            "",
            "  bool ok(){",
            "    return ord.size() == v;",
            "  }",
            "",
            "  bool cmp(int x, int y){",
            "    assert(x < v && y < v);",
            "    return inv[x] < inv[y];",
            "  }",
            "};",            
        ],
        "description": "トポロジカルソート"
    },

    "maximum_rectangle":{
        "prefix": "maximum_rectangle",
        "body":[
            "int maximum_rectangle(vec &h) {",
            "  int n = h.size();",
            "  stack<int> st;",
            "  vec L(n), R(n);",
            "  REP(i,n){",
            "    while (st.size() && h[st.top()] >= h[i]) st.pop();",
            "    L[i] = st.size() ? (st.top() + 1) : 0;",
            "    st.push(i);",
            "  }",
            "  while (st.size()) st.pop();",
            "  RREP(i,n){",
            "    while (st.size() > 0 && h[st.top()] >= h[i]) st.pop();",
            "    R[i] = st.size() ? st.top() : n;",
            "    st.push(i);",
            "  }",
            "  int res = 0;",
            "  REP(i,n){",
            "    res = max(res,h[i]*(R[i]-L[i]));",
            "  }",
            "  return res;",
            "}",
        ],
        "description": "ヒストグラム内の最大長方形"
    },

    "scc":{
        "prefix": "scc",
        "body":[
            "struct SCC{",
            "public:",
            "  int V,cnt = 0;",
            "  mat G,rG,edge,list;",
            "  vec vs,cmp,used;",
            "",
            "  SCC(int node_size) : V(node_size), G(V), rG(V), cmp(V), used(V,0) {}",
            "",    
            "  void add_edge(int from, int to) {",
            "    G[from].push_back(to);",
            "    rG[to].push_back(from);",
            "  }",
            "",    
            "  void dfs(int u) {",
            "    used[u]++;",
            "    for (int v:G[u]) if(!used[v]) dfs(v);",
            "    vs.push_back(u);",
            "  }",
            "",    
            "  void dfs(int u, int k) {",
            "    used[u]++;",
            "    cmp[u] = k;",
            "    for (int v:rG[u]) if(!used[v]) dfs(v,k);",
            "  }",
            "",    
            "  int solve(){",
            "    REP(i,V) if(!used[i]) dfs(i); ",
            "    REP(i,V) used[i] = 0;",
            "    RREP(i,vs.size()) if(!used[vs[i]]) dfs(vs[i],cnt++);",
            "    return cnt;",
            "  }",
            "",
            "  void make_graph(){",
            "    edge.resize(cnt);",
            "    list.resize(cnt);",
            "    REP(i,V){",
            "    list[cmp[i]].push_back(i);",
            "      for(int v:G[i]){",
            "        if(cmp[i] < cmp[v]) edge[cmp[i]].push_back(cmp[v]);",
            "      }",
            "    }",
            "  }",
            "  void clear(){",
            "    vec().swap(vs);",
            "    vec().swap(used);",
            "    mat().swap(G);",
            "    mat().swap(rG);",
            "  }",
            "};",
        ],
        "description": "強連結成分分解"
    },

    "binary_search":{
        "prefix": "bs",
        "body":[
            "int ng = $1, ok = $2;",
            "while (abs(ng-ok)>1) {",
            "  int mid = ng+(ok-ng)/2;",
            "  (check(mid)?ok:ng) = mid;",
            "}"
        ],
        "description": "にぶたん"
    },

    "suffix_array":{
        "prefix": "sa",
        "body":[
            "namespace internal {",
            "",
            "std::vector<int> sa_naive(const std::vector<int>& s) {",
            "    int n = s.size();",
            "    std::vector<int> sa(n);",
            "    std::iota(sa.begin(), sa.end(), 0);",
            "    std::sort(sa.begin(), sa.end(), [&](int l, int r) {",
            "        if (l == r) return false;",
            "        while (l < n && r < n) {",
            "            if (s[l] != s[r]) return s[l] < s[r];",
            "            l++;",
            "            r++;",
            "        }",
            "        return l == n;",
            "    });",
            "    return sa;",
            "}",
            "",
            "std::vector<int> sa_doubling(const std::vector<int>& s) {",
            "    int n = s.size();",
            "    std::vector<int> sa(n), rnk = s, tmp(n);",
            "    std::iota(sa.begin(), sa.end(), 0);",
            "    for (int k = 1; k < n; k *= 2) {",
            "        auto cmp = [&](int x, int y) {",
            "            if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];",
            "            int rx = x + k < n ? rnk[x + k] : -1;",
            "            int ry = y + k < n ? rnk[y + k] : -1;",
            "            return rx < ry;",
            "        };",
            "        std::sort(sa.begin(), sa.end(), cmp);",
            "        tmp[sa[0]] = 0;",
            "        for (int i = 1; i < n; i++) {",
            "            tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);",
            "        }",
            "        std::swap(tmp, rnk);",
            "    }",
            "    return sa;",
            "}",
            "",
            "// SA-IS, linear-time suffix array construction",
            "// Reference:",
            "// G. Nong, S. Zhang, and W. H. Chan,",
            "// Two Efficient Algorithms for Linear Time Suffix Array Construction",
            "template <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>",
            "std::vector<int> sa_is(const std::vector<int>& s, int upper) {",
            "    int n = s.size();",
            "    if (n == 0) return {};",
            "    if (n == 1) return {0};",
            "    if (n == 2) {",
            "        if (s[0] < s[1]) {",
            "            return {0, 1};",
            "        } else {",
            "            return {1, 0};",
            "        }",
            "    }",
            "    if (n < THRESHOLD_NAIVE) {",
            "        return sa_naive(s);",
            "    }",
            "    if (n < THRESHOLD_DOUBLING) {",
            "        return sa_doubling(s);",
            "    }",
            "",
            "    std::vector<int> sa(n);",
            "    std::vector<bool> ls(n);",
            "    for (int i = n - 2; i >= 0; i--) {",
            "        ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);",
            "    }",
            "    std::vector<int> sum_l(upper + 1), sum_s(upper + 1);",
            "    for (int i = 0; i < n; i++) {",
            "        if (!ls[i]) {",
            "            sum_s[s[i]]++;",
            "        } else {",
            "            sum_l[s[i] + 1]++;",
            "        }",
            "    }",
            "    for (int i = 0; i <= upper; i++) {",
            "        sum_s[i] += sum_l[i];",
            "        if (i < upper) sum_l[i + 1] += sum_s[i];",
            "    }",
            "",
            "    auto induce = [&](const std::vector<int>& lms) {",
            "        std::fill(sa.begin(), sa.end(), -1);",
            "        std::vector<int> buf(upper + 1);",
            "        std::copy(sum_s.begin(), sum_s.end(), buf.begin());",
            "        for (auto d : lms) {",
            "            if (d == n) continue;",
            "            sa[buf[s[d]]++] = d;",
            "        }",
            "        std::copy(sum_l.begin(), sum_l.end(), buf.begin());",
            "        sa[buf[s[n - 1]]++] = n - 1;",
            "        for (int i = 0; i < n; i++) {",
            "            int v = sa[i];",
            "            if (v >= 1 && !ls[v - 1]) {",
            "                sa[buf[s[v - 1]]++] = v - 1;",
            "            }",
            "        }",
            "        std::copy(sum_l.begin(), sum_l.end(), buf.begin());",
            "        for (int i = n - 1; i >= 0; i--) {",
            "            int v = sa[i];",
            "            if (v >= 1 && ls[v - 1]) {",
            "                sa[--buf[s[v - 1] + 1]] = v - 1;",
            "            }",
            "        }",
            "    };",
            "",
            "    std::vector<int> lms_map(n + 1, -1);",
            "    int m = 0;",
            "    for (int i = 1; i < n; i++) {",
            "        if (!ls[i - 1] && ls[i]) {",
            "            lms_map[i] = m++;",
            "        }",
            "    }",
            "    std::vector<int> lms;",
            "    lms.reserve(m);",
            "    for (int i = 1; i < n; i++) {",
            "        if (!ls[i - 1] && ls[i]) {",
            "            lms.push_back(i);",
            "        }",
            "    }",
            "",
            "    induce(lms);",
            "",
            "    if (m) {",
            "        std::vector<int> sorted_lms;",
            "        sorted_lms.reserve(m);",
            "        for (int v : sa) {",
            "            if (lms_map[v] != -1) sorted_lms.push_back(v);",
            "        }",
            "        std::vector<int> rec_s(m);",
            "        int rec_upper = 0;",
            "        rec_s[lms_map[sorted_lms[0]]] = 0;",
            "        for (int i = 1; i < m; i++) {",
            "            int l = sorted_lms[i - 1], r = sorted_lms[i];",
            "            int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;",
            "            int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;",
            "            bool same = true;",
            "            if (end_l - l != end_r - r) {",
            "                same = false;",
            "            } else {",
            "                while (l < end_l) {",
            "                    if (s[l] != s[r]) {",
            "                        break;",
            "                    }",
            "                    l++;",
            "                    r++;",
            "                }",
            "                if (l == n || s[l] != s[r]) same = false;",
            "            }",
            "            if (!same) rec_upper++;",
            "            rec_s[lms_map[sorted_lms[i]]] = rec_upper;",
            "        }",
            "",
            "        auto rec_sa =",
            "            sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);",
            "",
            "        for (int i = 0; i < m; i++) {",
            "            sorted_lms[i] = lms[rec_sa[i]];",
            "        }",
            "        induce(sorted_lms);",
            "    }",
            "    return sa;",
            "}",
            "",
            "}  // namespace internal",
            "",
            "std::vector<int> suffix_array(const std::vector<int>& s, int upper) {",
            "    assert(0 <= upper);",
            "    for (int d : s) {",
            "        assert(0 <= d && d <= upper);",
            "    }",
            "    auto sa = internal::sa_is(s, upper);",
            "    return sa;",
            "}",
            "",
            "template <class T> std::vector<int> suffix_array(const std::vector<T>& s) {",
            "    int n = s.size();",
            "    std::vector<int> idx(n);",
            "    iota(idx.begin(), idx.end(), 0);",
            "    sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });",
            "    std::vector<int> s2(n);",
            "    int now = 0;",
            "    for (int i = 0; i < n; i++) {",
            "        if (i && s[idx[i - 1]] != s[idx[i]]) now++;",
            "        s2[idx[i]] = now;",
            "    }",
            "    return internal::sa_is(s2, now);",
            "}",
            "",
            "std::vector<int> suffix_array(const std::string& s) {",
            "    int n = s.size();",
            "    std::vector<int> s2(n);",
            "    for (int i = 0; i < n; i++) {",
            "        s2[i] = s[i];",
            "    }",
            "    return internal::sa_is(s2, 255);",
            "}",
            "",
            "// Reference:",
            "// T. Kasai, G. Lee, H. Arimura, S. Arikawa, and K. Park,",
            "// Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its",
            "// Applications",
            "template <class T>",
            "std::vector<int> lcp_array(const std::vector<T>& s,",
            "                           const std::vector<int>& sa) {",
            "    int n = s.size();",
            "    assert(n >= 1);",
            "    std::vector<int> rnk(n);",
            "    for (int i = 0; i < n; i++) {",
            "        rnk[sa[i]] = i;",
            "    }",
            "    std::vector<int> lcp(n - 1);",
            "    int h = 0;",
            "    for (int i = 0; i < n; i++) {",
            "        if (h > 0) h--;",
            "        if (rnk[i] == 0) continue;",
            "        int j = sa[rnk[i] - 1];",
            "        for (; j + h < n && i + h < n; h++) {",
            "            if (s[j + h] != s[i + h]) break;",
            "        }",
            "        lcp[rnk[i] - 1] = h;",
            "    }",
            "    return lcp;",
            "}",
            "",
            "std::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {",
            "    int n = s.size();",
            "    std::vector<int> s2(n);",
            "    for (int i = 0; i < n; i++) {",
            "        s2[i] = s[i];",
            "    }",
            "    return lcp_array(s2, sa);",
            "}",            
        ],
        "description": "suffix_array"
    },

    "floor_sum":{
        "prefix": "fls",
        "body":[
            "long long floor_sum(long long n, long long m, long long a, long long b) {",
            "  long long ans = 0;",
            "  if (a >= m) {",
            "    ans += (n - 1) * n * (a / m) / 2;",
            "    a %= m;",
            "  }",
            "  if (b >= m) {",
            "    ans += n * (b / m);",
            "    b %= m;",
            "  }",
            "",
            "  long long y_max = (a * n + b) / m, x_max = (y_max * m - b);",
            "  if (y_max == 0) return ans;",
            "  ans += (n - (x_max + a - 1) / a) * y_max;",
            "  ans += floor_sum(y_max, a, m, (a - x_max % a) % a);",
            "  return ans;",
            "}",
        ],
        "description": "floor_sum"
    },

    "two_sat":{
        "prefix": "sat",
        "body":[
            "struct two_sat {",
            "  template <class E> struct csr {",
            "      std::vector<int> start;",
            "      std::vector<E> elist;",
            "      csr(int n, const std::vector<std::pair<int, E>>& edges)",
            "          : start(n + 1), elist(edges.size()) {",
            "          for (auto e : edges) {",
            "              start[e.first + 1]++;",
            "          }",
            "          for (int i = 1; i <= n; i++) {",
            "              start[i] += start[i - 1];",
            "          }",
            "          auto counter = start;",
            "          for (auto e : edges) {",
            "              elist[counter[e.first]++] = e.second;",
            "          }",
            "      }",
            "  };",
            "",
            "  // Reference:",
            "  // R. Tarjan,",
            "  // Depth-First Search and Linear Graph Algorithms",
            "  struct scc_graph {",
            "    public:",
            "      scc_graph(int n) : _n(n) {}",
            "",
            "      int num_vertices() { return _n; }",
            "",
            "      void add_edge(int from, int to) { edges.push_back({from, {to}}); }",
            "",
            "      // @return pair of (# of scc, scc id)",
            "      std::pair<int, std::vector<int>> scc_ids() {",
            "          auto g = csr<edge>(_n, edges);",
            "          int now_ord = 0, group_num = 0;",
            "          std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);",
            "          visited.reserve(_n);",
            "          auto dfs = [&](auto self, int v) -> void {",
            "              low[v] = ord[v] = now_ord++;",
            "              visited.push_back(v);",
            "              for (int i = g.start[v]; i < g.start[v + 1]; i++) {",
            "                  auto to = g.elist[i].to;",
            "                  if (ord[to] == -1) {",
            "                      self(self, to);",
            "                      low[v] = std::min(low[v], low[to]);",
            "                  } else {",
            "                      low[v] = std::min(low[v], ord[to]);",
            "                  }",
            "              }",
            "              if (low[v] == ord[v]) {",
            "                  while (true) {",
            "                      int u = visited.back();",
            "                      visited.pop_back();",
            "                      ord[u] = _n;",
            "                      ids[u] = group_num;",
            "                      if (u == v) break;",
            "                  }",
            "                  group_num++;",
            "              }",
            "          };",
            "          for (int i = 0; i < _n; i++) {",
            "              if (ord[i] == -1) dfs(dfs, i);",
            "          }",
            "          for (auto& x : ids) {",
            "              x = group_num - 1 - x;",
            "          }",
            "          return {group_num, ids};",
            "      }",
            "",
            "      std::vector<std::vector<int>> scc() {",
            "          auto ids = scc_ids();",
            "          int group_num = ids.first;",
            "          std::vector<int> counts(group_num);",
            "          for (auto x : ids.second) counts[x]++;",
            "          std::vector<std::vector<int>> groups(ids.first);",
            "          for (int i = 0; i < group_num; i++) {",
            "              groups[i].reserve(counts[i]);",
            "          }",
            "          for (int i = 0; i < _n; i++) {",
            "              groups[ids.second[i]].push_back(i);",
            "          }",
            "          return groups;",
            "      }",
            "",
            "    private:",
            "      int _n;",
            "      struct edge {",
            "          int to;",
            "      };",
            "      std::vector<std::pair<int, edge>> edges;",
            "  };",
            "",
            "  public:",
            "    two_sat() : _n(0), scc(0) {}",
            "    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}",
            "",
            "    void add_clause(int i, bool f, int j, bool g) {",
            "        assert(0 <= i && i < _n);",
            "        assert(0 <= j && j < _n);",
            "        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));",
            "        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));",
            "    }",
            "    bool satisfiable() {",
            "        auto id = scc.scc_ids().second;",
            "        for (int i = 0; i < _n; i++) {",
            "            if (id[2 * i] == id[2 * i + 1]) return false;",
            "            _answer[i] = id[2 * i] < id[2 * i + 1];",
            "        }",
            "        return true;",
            "    }",
            "    std::vector<bool> answer() { return _answer; }",
            "",
            "  private:",
            "    int _n;",
            "    std::vector<bool> _answer;",
            "    scc_graph scc;",
            "};",            
        ],
        "description": "2SAT"
    },

    "lazy_segment_tree_abst":{
        "prefix": "lazy",
        "body":[
            "// //高速化",
            "// template <typename T,typename E, typename F, typename G, typename H>",
            "// struct SegmentTree{",
            "//   // using F = function<T(T,T)>;",
            "//   // using G = function<T(T,E)>;",
            "//   // using H = function<E(E,E)>;",
            "//   ~~~",
            "// };",
            "//   SegmentTree<int, int, decltype(f), decltype(g), decltype(h)> seg(f,g,h,ti,ei);",
            "template <typename T,typename E>",
            "struct SegmentTree{",
            "  using F = function<T(T,T)>;",
            "  using G = function<T(T,E,int)>;",
            "  using H = function<E(E,E)>;",
            "  int n;",
            "  F f;",
            "  G g;",
            "  H h;",
            "  T ti;",
            "  E ei;",
            "  vector<T> dat;",
            "  vector<E> laz;",
            "  SegmentTree(F f,G g,H h,T ti,E ei):",
            "    f(f),g(g),h(h),ti(ti),ei(ei){}",
            "    SegmentTree(){}",
            "",  
            "  void init(int n_){",
            "    n=1;",
            "    while(n<n_) n<<=1;",
            "    dat.assign((n<<1)-1,ti);",
            "    laz.assign((n<<1)-1,ei);",
            "  }",
            "  void build(const vector<T> &v){",
            "    int n_=v.size();",
            "    init(n_);",
            "    for(int i=0;i<n_;i++) dat[n+i-1]=v[i];",
            "    for(int i=n-2;i>=0;i--)",
            "      dat[i]=f(dat[(i<<1)+2],dat[(i<<1)|1]);",
            "  }",
            "  void eval(int k,int l,int r){",
            "    if(laz[k]==ei)return;",
            "    dat[k] = g(dat[k], laz[k], r-l);",
            "    if(r-l>1){",
            "      laz[(k<<1)|1] = h(laz[(k<<1)|1], laz[k]);",
            "      laz[(k<<1)+2] = h(laz[(k<<1)+2], laz[k]);",
            "    }",
            "    laz[k]=ei;",
            "  }",
            "",
            "  void update(int a, int b, E x,int k=0,int l=0,int r=-1){",
            "    if(r<0)r=n;",
            "    eval(k,l,r);",
            "    if(r<=a||b<=l)return;",
            "    if(a<=l&&r<=b){",
            "      laz[k] = h(laz[k], x);",
            "      eval(k,l,r);",
            "    }",
            "    else {",
            "      update(a,b,x,(k<<1)|1,l,(l+r)/2);",
            "      update(a,b,x,(k<<1)+2,(l+r)/2,r);",
            "      dat[k]=f(dat[(k<<1)|1], dat[(k<<1)+2]);",
            "    }",
            "  }",
            "",
            "  T query(int a,int b,int k=0,int l=0,int r=-1){",
            "    if(r<0)r=n;",
            "    eval(k,l,r);",
            "    if(r<=a||b<=l)return ti;",
            "    if(a<=l&&r<=b)return dat[k];",
            "    T xl=query(a,b,(k<<1)|1,l,(l+r)/2);",
            "    T xr=query(a,b,(k<<1)+2,(l+r)/2,r);",
            "    return f(xl, xr);",
            "  }",
            "",
            "  //lower_find(l,r,fanc): fancを満たす区間[0,id)なるidの最小値を返す. ng < okのとき",
            "  template<typename C>",
            "  int lower_find(int a, int b, C &check, T x, int k=1, int l=0, int r=-1){",
            "    if(r<0)r=n;",
            "    if(!check(f(x,dat[k]))||r<=a||b<=l)return -1;",
            "    if(r-l==1)return l;",
            "    int xl = lower_find(a,b,check,x,(k<<1),l,(l+r)/2);",
            "    if(xl>=0)return xl;",
            "    x = f(x,dat[(k<<1)]);",
            "    return lower_find(a,b,check,x,(k<<1)|1,(l+r)/2,r);",
            "  }",
            "  template<typename C>",
            "  int lower_find(int a, int b, C &check){",
            "    T x=ti;",
            "    return lower_find(a,b,check,x);",
            "  }",
            "",
            "  //upper_find(l,r,fanc): fancを満たす区間[0,id)なるidの最小値を返す. ok < ngのとき",
            "  template<typename C>",
            "  int upper_find(int a, int b, C &check, T x, int k=2, int l=0, int r=-1){",
            "    if(r<0)r=n;",
            "    if(r<=a||b<=l)return -1;",
            "    if(r-l==1)return l;",
            "    if(check(f(x,dat[k]))){",
            "      int xr = upper_find(a,b,check,f(x,dat[k]),((k+1)<<1),(l+r)/2,r);",
            "      if(xr>=0)return xr;",
            "    }",
            "    return upper_find(a,b,check,x,(k<<1),l,(l+r)/2);",
            "  }",
            "  template<typename C>",
            "  int upper_find(int a, int b, C &check){",
            "    T x=ti;",
            "    return upper_find(a,b,check,x);",
            "  }",
            "};",
            "",
            "//ex) RAQ & RSQ",
            "//auto f = [](int a, int b){return a+b;};",
            "//auto g = [](int a, int b, int len){return a+b*len;};",
            "//auto h = [](int a, int b){return a+b;};",
            "",
            "//ex) RAQ & RMQ",
            "//auto f = [](int a, int b){return min(a,b);};",
            "//auto g = [](int a, int b, int len){return a+b;};",
            "//auto h = [](int a, int b){return a+b;};",
        ],
        "description": "抽象遅延セグ木"
    },

    "lazy_segment_tree_abst(broken)":{
        "prefix": "@@@@@@@@",
        "body":[
            "// 高速化",
            "// template <typename T,typename E, typename F, typename G, typename H>",
            "// struct SegmentTree{",
            "//   // using F = function<T(T,T)>;",
            "//   // using G = function<T(T,E)>;",
            "//   // using H = function<E(E,E)>;",
            "//   ~~~",
            "// };",
            "//   SegmentTree<int, int, decltype(f), decltype(g), decltype(h)> seg(f,g,h,ti,ei);",
            "template <typename T,typename E>",
            "struct LazySegmentTree{",
            "  using F = function<T(T,T)>;",
            "  using G = function<T(T,E,int)>;",
            "  using H = function<E(E,E)>;",
            "  F f;",
            "  G g;",
            "  H h;",
            "  T ti;",
            "  E ei;",
            "  int _n, size, log;",
            "  vector<T> dat;",
            "  vector<E> laz;",
            "  vector<int> len;",
            "  LazySegmentTree(F f,G g,H h,T ti,E ei):",
            "    f(f),g(g),h(h),ti(ti),ei(ei){}",
            "  void apply(int k) {dat[k] = f(dat[2*k], dat[2*k+1]);}",
            "  void all_apply(int k, E e) {",
            "    dat[k] = g(dat[k],e,len[MSB(k)]);",
            "    if (k < size) laz[k] = h(laz[k],e);",
            "  }",
            "  void push(int k) {",
            "    all_apply(2 * k, laz[k]);",
            "    all_apply(2 * k + 1, laz[k]);",
            "    laz[k] = ei;",
            "  }",
            "",
            "  void init(){",
            "    log = MSB(_n)+1;",
            "    size = 1 << log;",
            "    dat.assign(2*size,ti);",
            "    laz.assign(2*size,ei);",
            "    len.assign(log,1);",
            "    RREP(i,log-1) len[i] = len[i+1]*2;",
            "  }",
            "",
            "  void build(const vector<T> &v){",
            "    _n=v.size();",
            "    init();",
            "    for (int i = 0; i < _n; i++) dat[size + i] = v[i];",
            "    for (int i = size - 1; i >= 1; i--) apply(i);",
            "  }",
            "",
            "  void set(int p, T x) {",
            "    assert(0 <= p && p < _n);",
            "    p += size;",
            "    for (int i = log; i >= 1; i--) push(p >> i);",
            "    dat[p] = x;",
            "    for (int i = 1; i <= log; i++) apply(p >> i);",
            "  }",
            "",
            "  void update(int p, E e) {",
            "    assert(0 <= p && p < _n);",
            "    p += size;",
            "    for (int i = log; i >= 1; i--) push(p >> i);",
            "    dat[p] = g(dat[p],e,len[MSB(p)]);",
            "    for (int i = 1; i <= log; i++) apply(p >> i);",
            "  }",
            "  void update(int l, int r, E e) {",
            "    assert(0 <= l && l <= r && r <= _n);",
            "    if (l == r) return;",
            "",
            "    l += size; r += size;",
            "",
            "    for (int i = log; i >= 1; i--) {",
            "      if (((l >> i) << i) != l) push(l >> i);",
            "      if (((r >> i) << i) != r) push((r - 1) >> i);",
            "    }",
            "",
            "    int l2 = l, r2 = r;",
            "    while (l < r) {",
            "      if (l & 1) all_apply(l++, e);",
            "      if (r & 1) all_apply(--r, e);",
            "      l >>= 1;",
            "      r >>= 1;",
            "    }",
            "    l = l2; r = r2;",
            "",
            "    for (int i = 1; i <= log; i++) {",
            "      if (((l >> i) << i) != l) apply(l >> i);",
            "      if (((r >> i) << i) != r) apply((r - 1) >> i);",
            "    }",
            "  }",
            "",
            "  T get(int p) {",
            "      assert(0 <= p && p < _n);",
            "      p += size;",
            "      for (int i = log; i >= 1; i--) push(p >> i);",
            "      return dat[p];",
            "  }",
            "",
            "  T query(int l, int r) {",
            "    assert(0 <= l && l <= r && r <= _n);",
            "    if (l == r) return ti;",
            "    l += size; r += size;",
            "    for (int i = log; i >= 1; i--) {",
            "      if (((l >> i) << i) != l) push(l >> i);",
            "      if (((r >> i) << i) != r) push(r >> i);",
            "    }",
            "",
            "    T sml = ti, smr = ti;",
            "    while (l < r) {",
            "      if (l & 1) sml = f(sml, dat[l++]);",
            "      if (r & 1) smr = f(dat[--r], smr);",
            "      l >>= 1;",
            "      r >>= 1;",
            "    }",
            "",
            "    return f(sml, smr);",
            "  }",
            "",
            "",
            "  template<typename C> int max_right(int l, C check) {",
            "    assert(0 <= l && l <= _n);",
            "    if (l == _n) return _n;",
            "    l += size;",
            "    for (int i = log; i >= 1; i--) push(l >> i);",
            "    T sm = ti;",
            "    do {",
            "      while (l % 2 == 0) l >>= 1;",
            "      if (!check(f(sm, dat[l]))) {",
            "        while (l < size) {",
            "          push(l);",
            "          l = (2 * l);",
            "          if (check(f(sm, dat[l]))) {",
            "            sm = f(sm, dat[l]);",
            "            l++;",
            "          }",
            "        }",
            "        return l - size;",
            "      }",
            "      sm = f(sm, dat[l]);",
            "      l++;",
            "    } while ((l & -l) != l);",
            "    return _n;",
            "    }",
            "",
            "  template <class C> int min_left(int r, C check) {",
            "    assert(0 <= r && r <= _n);",
            "    if (r == 0) return 0;",
            "    r += size;",
            "    for (int i = log; i >= 1; i--) push((r - 1) >> i);",
            "    T sm = ti;",
            "    do {",
            "      r--;",
            "      while (r > 1 && (r % 2)) r >>= 1;",
            "      if (!check(f(dat[r], sm))) {",
            "        while (r < size) {",
            "          push(r);",
            "          r = (2 * r + 1);",
            "          if (check(f(dat[r], sm))) {",
            "            sm = f(dat[r], sm);",
            "            r--;",
            "          }",
            "        }",
            "        return r + 1 - size;",
            "      }",
            "      sm = f(dat[r], sm);",
            "    } while ((r & -r) != r);",
            "    return 0;",
            "  }",
            "};",
            "",
            "//ex) RAQ & RSQ",
            "//auto f = [](int a, int b){return a+b;};",
            "//auto g = [](int a, int b, int len){return a+b*len;};",
            "//auto h = [](int a, int b){return a+b;};",
            "",
            "//ex) RAQ & RMQ",
            "//auto f = [](int a, int b){return min(a,b);};",
            "//auto g = [](int a, int b, int len){return a+b;};",
            "//auto h = [](int a, int b){return a+b;};",            
        ],
        "description": "抽象遅延セグ木"
    },

    "segment_tree_abst":{
        "prefix": "seg",
        "body":[
            "template <typename T>",
            "struct SegmentTree{",
            "  using F = function<T(T,T)>;",
            "  int n,n_;",
            "  F f;",
            "  T ti;",
            "  vector<T> dat;",
            "  SegmentTree(){};",
            "  SegmentTree(F f,T ti):f(f),ti(ti){}",
            "",
            "  void init(){",
            "    n=1;",
            "    while(n<n_) n<<=1;",
            "    dat.assign(n<<1,ti);",
            "  }",
            "",
            "  void build(const vector<T> &v){",
            "    n_=v.size();",
            "    init();",
            "    for(int i=0;i<n_;i++) dat[n+i]=v[i];",
            "    for(int i=n-1;i;i--)",
            "      dat[i]=f(dat[(i<<1)|0],dat[(i<<1)|1]);",
            "  }",
            "",
            "  void update(int k,T x){",
            "    assert(0 <= k && k < n_);",
            "    dat[k+=n]=x;",
            "    while(k>>=1)",
            "      dat[k]=f(dat[(k<<1)|0],dat[(k<<1)|1]);",
            "  }",
            "",
            "  void add(int k,T x){",
            "    assert(0 <= k && k < n_);",
            "    dat[k+=n]+=x;",
            "    while(k>>=1)",
            "      dat[k]=f(dat[(k<<1)|0],dat[(k<<1)|1]);",
            "  }",
            "",
            "  T get(int k){",
            "    assert(0 <= k && k < n_);",
            "    return dat[n+k];",
            "  }",
            "",
            "  T query(int a,int b){",
            "    assert(0 <= a && a <= b && b <= n_);",
            "    T vl=ti, vr=ti;",
            "    for(int l=a+n,r=b+n;l<r;l>>=1,r>>=1) {",
            "      if(l&1) vl=f(vl,dat[l++]);",
            "      if(r&1) vr=f(dat[--r],vr);",
            "    }",
            "    return f(vl,vr);",
            "  }",
            "",
            "  template <class C> int max_right(int l, C check) {",
            "    assert(0 <= l && l <= n_);",
            "    if (l == n_) return n_;",
            "    l += n;",
            "    T sm = ti;",
            "    do {",
            "      while (l % 2 == 0) l >>= 1;",
            "      if (!check(f(sm, dat[l]))) {",
            "        while (l < n) {",
            "          l = (2 * l);",
            "          if (check(f(sm, dat[l]))) {",
            "            sm = f(sm, dat[l]);",
            "            l++;",
            "          }",
            "        }",
            "        return l - n;",
            "      }",
            "      sm = f(sm, dat[l]);",
            "      l++;",
            "    } while ((l & -l) != l);",
            "    return n_;",
            "  }",
            "",
            "  template <class C> int min_left(int r, C check) {",
            "    assert(0 <= r && r <= n_);",
            "    if (r == 0) return 0;",
            "    r += n;",
            "    T sm = ti;",
            "    do {",
            "      r--;",
            "      while (r > 1 && (r % 2)) r >>= 1;",
            "      if (!check(f(dat[r], sm))) {",
            "        while (r < n) {",
            "          r = (2 * r + 1);",
            "          if (check(f(dat[r], sm))) {",
            "            sm = f(dat[r], sm);",
            "            r--;",
            "          }",
            "        }",
            "        return r + 1 - n;",
            "      }",
            "      sm = f(dat[r], sm);",
            "    } while ((r & -r) != r);",
            "    return 0;",
            "  }",
            "};",            
        ],
        "description": "抽象セグ木"
    },

    "Centroid":{
        "prefix": "centroid",
        "body":[
            "struct Centroid{",
            "  vector<int> sz,dead;",
            "  vector<vector<int> > edge;",
            "  Centroid(){}",
            "  Centroid(int n):sz(n,1),dead(n,0),edge(n){}",
            " ",
            "  void add_edge(int u,int v){",
            "    edge[u].emplace_back(v);",
            "    edge[v].emplace_back(u);",
            "  }",
            " ",
            "  int dfs(int v,int p){",
            "    sz[v]=1;",
            "    for(int u:edge[v])",
            "      if(u!=p&&!dead[u]) sz[v]+=dfs(u,v);",
            "    return sz[v];",
            "  }",
            " ",
            "  void find(int v,int p,int tmp,vector<int> &cs) {",
            "    int ok=1;",
            "    for (int u:edge[v]){",
            "      if(u==p||dead[u]) continue;",
            "      find(u,v,tmp,cs);",
            "      ok&=(sz[u]<=tmp/2);",
            "    }",
            "    ok&=(tmp-sz[v]<=tmp/2);",
            "    if(ok) cs.push_back(v);",
            "  }",
            " ",
            "  vector<int> build(int r) {",
            "    int tmp=dfs(r,-1);",
            "    vector<int> cs;",
            "    find(r,-1,tmp,cs);",
            "    return cs;",
            "  }",
            " ",
            "  void disable(int v){",
            "    dead[v]=1;",
            "  }",
            " ",
            "  void enable(int v){",
            "    dead[v]=0;",
            "  }",
            " ",
            "  int alive(int v){",
            "    return !dead[v];",
            "  }",
            "};",            
        ],
        "description": "木の重心分解"
    },

    "Primefactorization":{
        "prefix": "pfact",
        "body":[
            "vector<int> pri;",
            "void init(int x){",
            "  vector<bool> flag(x+1,false);",
            "  for(int i = 2; i <= x; i++){",
            "    if(flag[i]) continue;",
            "    pri.emplace_back(i);",
            "    for(int j = i; j <= x; j+=i) flag[j] = true;",
            "  }",
            "}",
            " ",
            "map<long long,int> Primefactorization(long long x){",
            "  map<long long, int> mp;",
            "  for(int p:pri){",
            "    int cnt = 0;",
            "    if(p*p > x) break;",
            "    while(x%p==0) x /= p, cnt++;",
            "    if(cnt) mp[p] = cnt;",
            "  }",
            "  if(x != 1) mp[x] = 1;",
            "  return mp;",
            "}",
            
        ],
        "description": "素因数分解"
    },

    "Warshall–Floyd":{
        "prefix": "war",
        "body":[
            "vector<int> dist[n];",
            "REP(i,n) dist[i].assign(n,LINF);",
            "",
            "REP(i,n) dist[i][i] = 0;",
            "",
            "REP(k,n){",
            "  REP(i,n){",
            "    REP(j,n){",
            "      dist[i][j] = min(dist[i][j],dist[i][k] + dist[k][j]);",
            "    }",
            "  }",
            "}",
        ],
        "description": "ワーシャルフロイト"
    },
    
    "LIS":{
        "prefix": "LIS",
        "body":[
            "int LIS(const vector<int> &v) {",
            "  int n = v.size();",
            "  vector<int> dp(n, LINF);",
            "  REP(i,n) *lower_bound(dp.begin(), dp.end(), v[i]) = v[i];",
            "  return find(dp.begin(), dp.end(), LINF) - dp.begin();",
            "}",
        ],
        "description": "最長増加部分列"
    },

    "TwoEdgeConnectedComponent":{
        "prefix": "tecc",
        "body":[
            "struct LowLink {",
            "  set<pair<int, int>> bridge;",
            "  vector<int> articulation, ord, low;",
            "  vector<bool> used;",
            "  vector<vector<int>> g;",
            "  int n, k = 0;",
            "  LowLink(const vector<vector<int>> &g) : g(g) {",
            "    n = g.size();",
            "    ord.resize(n, 0);",
            "    low.resize(n, 0);",
            "    used.resize(n, false);",
            "  }",
            "  void dfs(int u, int prev) {",
            "    used[u] = true;",
            "    ord[u] = k++;",
            "    low[u] = ord[u];",
            "    bool is_articulation = false;",
            "    int cnt = 0;",
            "    for (auto v : g[u]) if (v != prev) {",
            "      if (!used[v]) {",
            "        cnt ++;",
            "        dfs(v, u);",
            "        low[u] = min(low[u], low[v]);",
            "        if (low[v] > ord[u]) {",
            "          bridge.emplace(min(u, v), max(u, v));",
            "        } ",
            "        if (prev != -1 && low[v] >= ord[u]) {",
            "          is_articulation = true;",
            "        }",
            "      } else {",
            "        low[u] = min(low[u], ord[v]);",
            "      }",
            "    }",
            "    if (prev == -1 && cnt > 1) is_articulation = true;",
            "    if (is_articulation) articulation.push_back(u);",
            "  }",
            "};",
            " ",
            "struct TwoEdgeConnectedComponent {",
            "  int n;",
            "  vector<vector<int>> g, tree;",
            "  vector<int> cmp,sz;",
            "  TwoEdgeConnectedComponent(){};",
            "  TwoEdgeConnectedComponent(const vector<vector<int>> &g) : g(g) {",
            "    n = (int) g.size();",
            "    cmp.assign(n, -1);",
            "  }",
            "  void build() {",
            "    LowLink lnk(g);",
            "    lnk.dfs(0, -1);",
            "    int k = 0;",
            "    function<void (int, int)> dfs = [&](int u, int prev) {",
            "      cmp[u] = k;",
            "      for (auto v : g[u]) if (cmp[v] == -1 && lnk.bridge.count({min(u, v), max(u, v)}) == 0) {",
            "        dfs(v, u);",
            "      }",
            "    };",
            "    for (int i = 0; i < n; i ++) if (cmp[i] == -1) {",
            "      dfs(i, -1);",
            "      k ++;",
            "    }",
            "    tree.resize(k);",
            "    sz.assign(k,0);",
            "    for(int i = 0; i < n; i++) sz[cmp[i]]++;",
            "    for (auto e : lnk.bridge) {",
            "      tree[cmp[e.first]].push_back(cmp[e.second]);",
            "      tree[cmp[e.second]].push_back(cmp[e.first]);",
            "    }",
            "  }",
            "};",
        ],
        "description": "二重辺連結成分分解"
    },

    "ChineseRem":{
        "prefix": "chinese",
        "body":[
            "inline int mod(int a, int m) {",
            "  return (a % m + m) % m;",
            "}",
            "",
            "int extGcd(int a, int b, int &p, int &q) {",
            "  if (b == 0) { p = 1; q = 0; return a; }",  
            "  int d = extGcd(b, a%b, q, p);",
            "  q -= a/b * p;",
            "  return d;",
            "}",
            "",
            "pair<int,int> ChineseRem(int b1, int m1, int b2, int m2) {",
            "  int p,q;",
            "  int d = extGcd(m1, m2, p, q);",
            "  if ((b2 - b1) % d != 0) return make_pair(0, -1);",
            "  int m = m1 * (m2/d);",
            "  int tmp = (b2 - b1) / d * p % (m2/d);",
            "  int r = mod(b1 + m1 * tmp, m);",
            "  return make_pair(r, m);",
            "}",
        ],
        "description": "中国剰余定理"
    },

    "mod_set":{
        "prefix": "modset",
        "body":[
            "void add(int &a, int b){",
            "  a = ((a+b) % MOD + MOD) % MOD;",
            "}",
            "",
            "inline int mul(int a, int b) {",
            "    add(a,0); add(b,0);",
            "    #if !defined(_WIN32) || defined(_WIN64)",
            "      return (int) ((long long) a * b % MOD);",
            "    #endif",
            "      unsigned long long x = (long long) a * b;",
            "      unsigned xh = (unsigned) (x >> 32), xl = (unsigned) x, d, m;",
            "      asm(",
            "        \"divl %4; \\n\\t\"",
            "        : \"=a\" (d), \"=d\" (m)",
            "        : \"d\" (xh), \"a\" (xl), \"r\" (MOD)",
            "      );",
            "      return m;",
            "}",
            "",
            "inline int modpow(int a, long long b) {",
            "  int res = 1;",
            "  while (b > 0) {",
            "    if (b & 1) {",
            "      res = mul(res, a);",
            "      }",
            "      a = mul(a, a);",
            "      b >>= 1;",
            "  }",
            "  return res;",
            "}",
            "",
            "inline int inv(int a) {",
            "    a %= MOD;",
            "    if (a < 0) a += MOD;",
            "    int b = MOD, u = 0, v = 1;",
            "    while (a) {",
            "      int t = b / a;",
            "      b -= t * a; swap(a, b);",
            "      u -= t * v; swap(u, v);",
            "    }",
            "    assert(b == 1);",
            "    if (u < 0) u += MOD;",
            "    return u;",
            "}"
        ],
        "description": "MODいろいろ"
    },



    "convex_hull":{
        "prefix": "convex",
        "body":[
            "double det(P x,P y){",
            "  return x.fs*y.sc-x.sc*y.fs;",
            "}",
            "P sub(P x,P y){",
            "  return P(x.first-y.first, x.second-y.second);",
            "}",
            "",  
            "vector<P> Convex_Hull(vector<P>& p){",
            "  int n = p.size(), k = 0;",
            "  sort(p.begin(),p.end());",
            "  vector<P> q(2*n);",
            "  //下側凸包",
            "  REP(i,n){",
            "    while(k > 1 && det(sub(q[k-1],q[k-2]),sub(p[i],q[k-1])) <= 0) k--;",
            "    q[k++] = p[i];",
            "  }",
            "  //上側凸包",
            "  int t = k;",
            "  RREP(i,n-1){",    
            "    while(k > t && det(sub(q[k-1],q[k-2]),sub(p[i],q[k-1])) <= 0) k--;",
            "    q[k++] = p[i];",
            "  }",
            "  q.resize(k);",
            "  return q;",
            "}"
        ],
        "description": "凸包"
    },

    "Rolling_Hash":{
        "prefix": "roll",
        "body":[
            "template<class Z> Z rng(Z a, Z b) {",
                "  static mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());",
                "  return uniform_int_distribution<Z>(a, b - 1)(mt);",
                "}",
                " ",
                "struct RollingHash {",
                "  static constexpr uint64_t P0 = 4e9 + 7;",
                "  static constexpr uint64_t P1 = 4e9 + 9;",
                "  static uint64_t B0;",
                "  static uint64_t B1;",
                "  static vector<uint64_t> powB0;",
                "  static vector<uint64_t> powB1;",
                "  int n;",
                "  vector<uint64_t> h0;",
                "  vector<uint64_t> h1;",
                "  void init(string s){",
                "    n = s.size();",
                "    h0.resize(n+1); h1.resize(n+1);",
                "    for (int i = 0; i < n; ++i) {",
                "      h0[i + 1] = (h0[i] * B0 + s[i]) % P0;",
                "      h1[i + 1] = (h1[i] * B1 + s[i]) % P1;",
                "    }",
                "    while (powB0.size() <= n) {",
                "      powB0.push_back(powB0.back() * B0 % P0);",
                "      powB1.push_back(powB1.back() * B1 % P1);",
                "    }",
                "  }",
                "  void add(char in) {",
                "      h0.push_back((h0.back() * B0 + in) % P0);",
                "      h1.push_back((h1.back() * B1 + in) % P1);",
                "      powB0.push_back(powB0.back() * B0 % P0);",
                "      powB1.push_back(powB1.back() * B1 % P1);",
                "  }",
                "  uint64_t get0(int l, int r) { return (h0[r] + (P0 - h0[l]) * powB0[r - l]) % P0; }",
                "  uint64_t get1(int l, int r) { return (h1[r] + (P1 - h1[l]) * powB1[r - l]) % P1; }",
                "  pair<uint64_t, uint64_t> get(int l, int r) {",
                "      pair<uint64_t, uint64_t> a;",
                "      a.first = get0(l, r);",
                "      a.second = get1(l, r);",
                "      return a;",
                "  }",
                "  bool match(int l0, int r0, int l1, int r1) {",
                "    return get0(l0, r0) == get0(l1, r1) and get1(l0, r0) == get1(l1, r1);",
                "  }",
                "};",
                "uint64_t RollingHash::B0 = rng<unsigned>(1, RollingHash::P0);",
                "uint64_t RollingHash::B1 = rng<unsigned>(1, RollingHash::P1);",
                "vector<uint64_t> RollingHash::powB0{1};",
                "vector<uint64_t> RollingHash::powB1{1};",
        ],
        "description": "Rolling_Hash"
    },

    "BigInt":{
        "prefix": "bint",
        "body":[
            "const int DEFAULT_SIZE = 1000;",
            "struct Bigint : vector<long long> {",
            "    static const long long BASE = 100000000;",
            "    static const int BASE_DIGIT = 8;",
            "    int sign;",
            "    ",
            "    Bigint() : vector<long long>(1, 0) { sign = 1; }",
            "    Bigint(long long num) : vector<long long>(DEFAULT_SIZE, 0) {",
            "        sign = 1; if (num < 0) sign = -1, num = -num;",
            "        (*this)[0] = num;",
            "        (*this).normalize();",
            "    }",
            "    Bigint(int SIZE, long long num) : vector<long long>(SIZE, 0) {",
            "        sign = 1; if (num < 0) sign = -1, num = -num;",
            "        (*this)[0] = num;",
            "        (*this).normalize();",
            "    }",
            "    ",
            "    Bigint& normalize() {",
            "        long long c = 0;",
            "        for (int i = 0;; ++i) {",
            "            if (i >= (*this).size()) (*this).push_back(0);",
            "            if ((*this)[i] < 0 && i+1 >= (*this).size()) (*this).push_back(0);",
            "            while ((*this)[i] < 0) { (*this)[i+1] -= 1; (*this)[i] += BASE; }",
            "            long long a = (*this)[i] + c;",
            "            (*this)[i] = a % BASE;",
            "            c = a / BASE;",
            "            if (c == 0 && i == (*this).size()-1) break;",
            "        }",
            "        return (*this);",
            "    }",
            "    ",
            "    inline Bigint operator - () {",
            "        Bigint res = (*this);",
            "        bool allzero = true; for (int i = 0; i < res.size(); ++i) if (res[i] != 0) { allzero = false; break; }",
            "        if (!allzero) res.sign *= -1;",
            "        return res;",
            "    }",
            "    inline const Bigint& operator += (const Bigint &x);",
            "    inline const Bigint& operator -= (const Bigint &x);",
            "    inline const Bigint& operator *= (long long x);",
            "    inline const Bigint& operator *= (const Bigint &x);",
            "    inline const Bigint& operator /= (long long x);",
            "    inline const Bigint& operator /= (const Bigint &x);",
            "    inline const Bigint& operator %= (long long x);",
            "    inline const Bigint& operator %= (const Bigint &x);",
            "};",
            " ",
            "inline Bigint abs(const Bigint &x) {",
            "    Bigint z = x;",
            "    if (z.sign == -1) z.sign = 1;",
            "    return z;",
            "}",
            "inline Bigint conv(const string &s) {",
            "    Bigint res = 0;",
            "    for (int i = 0; i < s.size(); ++i) {",
            "        res += (long long)(s[i] - '0');",
            "        if (i != s.size()-1) res *= 10;",
            "    }",
            "    return res;",
            "}",
            "ostream &operator << (ostream &os, const Bigint &x) {",
            "    if (x.sign == -1) os << '-';",
            "    int d = (int)x.size()-1;",
            "    for (d = (int)x.size()-1; d >= 0; --d) if (x[d] > 0) break;",
            "    if (d == -1) os << 0;",
            "    else os << x[d];",
            "    for (int i = d-1; i >= 0; --i) { os.width(Bigint::BASE_DIGIT); os.fill('0'); os << x[i]; }",
            "    return os;",
            "}",
            "istream &operator >> (istream &is, Bigint &x) {",
            "    string s; is >> s;",
            "    x = conv(s);",
            "    return is;",
            "}",
            "inline string tostr(const Bigint &x) {",
            "    stringstream ss;",
            "    ss << x;",
            "    return ss.str();",
            "}",
            "bool operator > (Bigint x, Bigint y) {",
            "    x.normalize(); y.normalize();",
            "    if (x.sign > y.sign) return true;",
            "    else if (x.sign < y.sign) return false;",
            "    else {",
            "        while (x.size() < y.size()) x.push_back(0);",
            "        while (x.size() > y.size()) y.push_back(0);",
            "        if (x.sign == 1) {",
            "            for (int i = (int)x.size()-1; i >= 0; --i) if (x[i] != y[i]) return x[i] > y[i];",
            "            return false;",
            "        }",
            "        else {",
            "            for (int i = (int)x.size()-1; i >= 0; --i) if (x[i] != y[i]) return x[i] < y[i];",
            "            return false;",
            "        }",
            "    }",
            "}",
            "bool operator < (Bigint x, Bigint y) { return y > x; }",
            "bool operator <= (Bigint x, Bigint y) { return !(x > y); }",
            "bool operator >= (Bigint x, Bigint y) { return !(y > x); }",
            "bool operator != (Bigint x, Bigint y) { return (x > y) || (y > x); }",
            "bool operator == (Bigint x, Bigint y) { return !(x > y) && !(y > x); }",
            " ",
            "inline Bigint operator + (Bigint x, Bigint y) {",
            "    while (x.size() < y.size()) x.push_back(0);",
            "    while (x.size() > y.size()) y.push_back(0);",
            "    Bigint z((int)x.size(), 0);",
            "    if (x.sign == y.sign) {",
            "        z.sign = x.sign;",
            "        for (int i = 0; i < x.size(); ++i) z[i] = x[i] + y[i];",
            "    }",
            "    else {",
            "        if (x.sign == -1) swap(x, y);",
            "        if (x >= -y) { z.sign = 1; for (int i = 0; i < x.size(); ++i) z[i] = x[i] - y[i]; }",
            "        else { z.sign = -1; for (int i = 0; i < x.size(); ++i) z[i] = y[i] - x[i]; }",
            "    }",
            "    return z.normalize();",
            "}",
            "inline Bigint operator - (Bigint x, Bigint y) {",
            "    y = -y;",
            "    return x + y;",
            "}",
            "inline Bigint operator * (Bigint x, long long a) {",
            "    Bigint z((int)x.size(), 0);",
            "    if ( (x.sign == 1 && a >= 0) || (x.sign == -1 && a < 0) ) z.sign = 1;",
            "    else z.sign = -1;",
            "    if (a < 0) a = -a;",
            "    for (int i = 0; i < x.size(); ++i) z[i] = x[i] * a;",
            "    return z.normalize();",
            "}",
            "inline Bigint operator * (Bigint x, Bigint y) {",
            "    int tx = (int)x.size()-1, ty = (int)y.size()-1;",
            "    for (tx = (int)x.size()-1; tx >= 0; --tx) if (x[tx] > 0) break;",
            "    for (ty = (int)y.size()-1; ty >= 0; --ty) if (y[ty] > 0) break;",
            "    Bigint z(tx+ty+5, 0);",
            "    if (x.sign == y.sign) z.sign = 1;",
            "    else z.sign = -1;",
            "    for (int i = 0; i <= tx; ++i) {",
            "        for (int j = 0; j <= ty && i+j < z.size()-1; ++j) {",
            "            long long val = x[i] * y[j] + z[i+j];",
            "            z[i+j+1] += val / Bigint::BASE;",
            "            z[i+j] = val % Bigint::BASE;",
            "        }",
            "    }",
            "    return z.normalize();",
            "}",
            "pair<Bigint, long long> divmod(Bigint x, long long a) {",
            "    long long c = 0, t = 0;",
            "    for (int i = (int)x.size()-1; i >= 0; --i) {",
            "        t = Bigint::BASE * c + x[i];",
            "        x[i] = t / a;",
            "        c = t % a;",
            "    }",
            "    x.normalize();",
            "    return pair<Bigint, long long>(x, c);",
            "}",
            "Bigint operator / (Bigint x, long long a) {",
            "    return divmod(x, a).first;",
            "}",
            "long long operator % (Bigint x, long long a) {",
            "    return divmod(x, a).second;",
            "}",
            "pair<Bigint, Bigint> divmod(Bigint x, Bigint y) {",
            "    Bigint zero = 0;",
            "    if (abs(x) < abs(y)) return pair<Bigint, Bigint>(zero, x);",
            "    Bigint ay = abs(y), q((int)x.size(), 0), r((int)y.size(), 0);",
            "    int tx = (int)x.size()-1;",
            "    for (tx = (int)x.size()-1; tx >= 0; --tx) if (x[tx] > 0) break;",
            "    for (int i = tx; i >= 0; --i) {",
            "        r = r * Bigint::BASE + x[i];",
            "        long long lo = 0, hi = Bigint::BASE;",
            "        if (r >= ay) {",
            "            while (hi - lo > 1) {",
            "                long long mid = (hi + lo) / 2;",
            "                if (ay * mid > r) hi = mid;",
            "                else lo = mid;",
            "            }",
            "            r = r - ay * lo;",
            "        }",
            "        q[i] = lo;",
            "    }",
            "    if (x.sign == -1 || y.sign == -1) q.sign = -1, r.sign = -1;",
            "    return make_pair(q.normalize(), r.normalize());",
            "}",
            "Bigint operator / (Bigint x, Bigint y) {",
            "    return divmod(x, y).first;",
            "}",
            "Bigint operator % (Bigint x, Bigint y) {",
            "    return divmod(x, y).second;",
            "}",
            "inline Bigint pow(Bigint a, long long n) {",
            "    Bigint res = 1;",
            "    while (n > 0) { if (n & 1) { res = res * a; } a = a * a; n >>= 1; }",
            "    return res;",
            "}",
            "Bigint sqrt(Bigint num) {",
            "    Bigint lo = 1, hi = num;",
            "    while (hi - lo > 1) {",
            "        Bigint med = (lo + hi) / 2;",
            "        if (med * med > num) hi = med;",
            "        else lo = med;",
            "    }",
            "    return lo;",
            "}",
            "inline const Bigint& Bigint::operator += (const Bigint &x) {*this = *this + x; return *this;}",
            "inline const Bigint& Bigint::operator -= (const Bigint &x) {*this = *this - x; return *this;}",
            "inline const Bigint& Bigint::operator *= (long long x) {*this = *this * x; return *this;}",
            "inline const Bigint& Bigint::operator *= (const Bigint &x) {*this = *this * x; return *this;}",
            "inline const Bigint& Bigint::operator /= (long long x) {*this = *this / x; return *this;}",
            "inline const Bigint& Bigint::operator /= (const Bigint &x) {*this = *this / x; return *this;}",
            "inline const Bigint& Bigint::operator %= (long long x) {*this = *this % x; return *this;}",
            "inline const Bigint& Bigint::operator %= (const Bigint &x) {*this = *this % x; return *this;}",            
        ],
        "description": "BigInt"
    },


    "template":{
        "prefix": "temp",
        "body":[
            "// warm heart, wagging tail,and a smile just for you!",
            "//                                                                     ███████████",
            "//                                                                   ███╬╬╬╬╬╬╬╬╬╬███",
            "//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███",
            "//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██",
            "//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██",
            "//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██",
            "//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██",
            "//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████",
            "//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██",
            "//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███",
            "//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██",
            "//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████",
            "//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████",
            "//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██",
            "// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██",
            "// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███",
            "// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████",
            "// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████",
            "//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██",
            "//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████",
            "//                         ███████                           █████  ███████████████████  ",
            "//",
            "#include \"bits/stdc++.h\"",
            "using namespace std;",
            "#define INF (1<<30)",
            "#define LINF (1LL<<60)",
            "#define fs first",
            "#define sc second",
            "#define int long long",
            "#define FOR(i,a,b) for(int i=(a);i<(b);++i)",
            "#define FOR2(i,a,b) for(int i=(a);i<=(b);++i)",
            "#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)",
            "#define RFOR2(i,a,b) for(int i = (b);i>=(a);--i)",
            "#define REP(i,n)  FOR(i,0,(n))",
            "#define REP2(i,n)  FOR2(i,0,(n))",
            "#define RREP(i,n) RFOR(i,0,(n))",
            "#define RREP2(i,n) RFOR2(i,0,(n))",
            "#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)",
            "#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)",
            "#define range(i,a,b) ((a)<=(i) && (i)<(b))",
            "#define range2(i,a,b) ((a)<=(i) && (i)<=(b))",
            "#define debug(x)  cout << #x << \" = \" << (x) << endl",
            "#define SP << \" \" << ",
            "template<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){if(a>b) {a=b; return true;} else return false;}",
            "template<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){if(a<b) {a=b; return true;} else return false;}",
            "#define MSB(x) (63-__builtin_clzll(x))",
            "#define pcnt(x) (__builtin_popcountll(x))",
            "#define parity(i,j) (i&(1LL<<j))",
            "typedef pair<int,int> P;",
            "typedef tuple<int,int,int> T;",
            "typedef vector<int> vec;",
            "typedef vector<vector<int>> mat;",
            "",
            "void solve(){",
            "  ",
            "}",
            "",
            "signed main(){",
            "  ios::sync_with_stdio(false);",
            "  cin.tie(0);",
            "",
            "  int T = 1;",
            "  // cin >> T;",
            "",
            "  while(T--) solve();",
            "",
            "  return 0;",
            "}",
        ],
        "description": "雛形"
    }

        "geometry":{
            "prefix": "geo",
            "body":[
                "#define EPS (1e-10)",
                "#define equals(a,b) (fabs((a)-(b)) < EPS)",
                "#define PI 3.141592653589793238",
                "",
                "// COUNTER CLOCKWISE",
                "static const int CCW_COUNTER_CLOCKWISE = 1;",
                "static const int CCW_CLOCKWISE = -1;",
                "static const int CCW_ONLINE_BACK = 2;",
                "static const int CCW_ONLINE_FRONT = -2;",
                "static const int CCW_ON_SEGMENT = 0;",
                "",
                "//Intercsect Circle & Circle",
                "static const int ICC_SEPERATE = 4;",
                "static const int ICC_CIRCUMSCRIBE = 3;",
                "static const int ICC_INTERSECT = 2;",
                "static const int ICC_INSCRIBE = 1;",
                "static const int ICC_CONTAIN = 0;",
                "",
                "struct Point{",
                "  double x,y;",
                "  Point(){}",
                "  Point(double x,double y) :x(x),y(y){}",
                "  Point operator+(Point p) {return Point(x+p.x,y+p.y);}",
                "  Point operator-(Point p) {return Point(x-p.x,y-p.y);}",
                "  Point operator*(double k){return Point(x*k,y*k);}",
                "  Point operator/(double k){return Point(x/k,y/k);}",
                "  double norm(){return x*x+y*y;}",
                "  double abs(){return sqrt(norm());}",
                "",
                "  bool operator < (const Point &p) const{",
                "    return x!=p.x?x<p.x:y<p.y;",
                "    //grid-point only",
                "    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;",
                "  }",
                "",
                "  bool operator == (const Point &p) const{",
                "    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;",
                "  }",
                "};",
                "",
                "struct EndPoint{",
                "  Point p;",
                "  int seg,st;",
                "  EndPoint(){}",
                "  EndPoint(Point p,int seg,int st):p(p),seg(seg),st(st){}",
                "  bool operator<(const EndPoint &ep)const{",
                "    if(p.y==ep.p.y) return st<ep.st;",
                "    return p.y<ep.p.y;",
                "  }",
                "};",
                "",
                "istream &operator >> (istream &is,Point &p){",
                "  is>>p.x>>p.y;",
                "  return is;",
                "}",
                "",
                "ostream &operator << (ostream &os,Point p){",
                "  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;",
                "  return os;",
                "}",
                "",
                "bool sort_x(Point a,Point b){",
                "  return a.x!=b.x?a.x<b.x:a.y<b.y;",
                "}",
                "",
                "bool sort_y(Point a,Point b){",
                "  return a.y!=b.y?a.y<b.y:a.x<b.x;",
                "}",
                "",
                "typedef Point Vector;",
                "typedef vector<Point> Polygon;",
                "",
                "istream &operator >> (istream &is,Polygon &p){",
                "  for(int i=0;i<(int)p.size();i++) is>>p[i];",
                "  return is;",
                "}",
                "",
                "struct Segment{",
                "  Point p1,p2;",
                "  Segment(){}",
                "  Segment(Point p1, Point p2):p1(p1),p2(p2){}",
                "};",
                "typedef Segment Line;",
                "",
                "istream &operator >> (istream &is,Segment &s){",
                "  is>>s.p1>>s.p2;",
                "  return is;",
                "}",
                "",
                "struct Circle{",
                "  Point c;",
                "  double r;",
                "  Circle(){}",
                "  Circle(Point c,double r):c(c),r(r){}",
                "};",
                "",
                "istream &operator >> (istream &is,Circle &c){",
                "  is>>c.c>>c.r;",
                "  return is;",
                "}",
                "",
                "double norm(Vector a){",
                "  return a.x*a.x+a.y*a.y;",
                "}",
                "double abs(Vector a){",
                "  return sqrt(norm(a));",
                "}",
                "double dot(Vector a,Vector b){",
                "  return a.x*b.x+a.y*b.y;",
                "}",
                "double cross(Vector a,Vector b){",
                "  return a.x*b.y-a.y*b.x;",
                "}",
                "",
                "Point orth(Point p){return Point(-p.y,p.x);}",
                "",
                "bool isOrthogonal(Vector a,Vector b){",
                "  return equals(dot(a,b),0.0);",
                "}",
                "",
                "bool isOrthogonal(Point a1,Point a2,Point b1,Point b2){",
                "  return isOrthogonal(a1-a2,b1-b2);",
                "}",
                "",
                "bool isOrthogonal(Segment s1,Segment s2){",
                "  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);",
                "}",
                "",
                "bool isParallel(Vector a,Vector b){",
                "  return equals(cross(a,b),0.0);",
                "}",
                "",
                "bool isParallel(Point a1,Point a2,Point b1,Point b2){",
                "  return isParallel(a1-a2,b1-b2);",
                "}",
                "",
                "bool isParallel(Segment s1,Segment s2){",
                "  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);",
                "}",
                "",
                "Point project(Segment s,Point p){",
                "  Vector base=s.p2-s.p1;",
                "  double r=dot(p-s.p1,base)/norm(base);",
                "  return s.p1+base*r;",
                "}",
                "",
                "Point reflect(Segment s,Point p){",
                "  return p+(project(s,p)-p)*2.0;",
                "}",
                "",
                "double arg(Vector p){",
                "  return atan2(p.y,p.x);",
                "}",
                "",
                "Vector polar(double a,double r){",
                "  return Point(cos(r)*a,sin(r)*a);",
                "}",
                "",
                "int ccw(Point p0,Point p1,Point p2);",
                "bool intersectSS(Point p1,Point p2,Point p3,Point p4);",
                "bool intersectSS(Segment s1,Segment s2);",
                "bool intersectPS(Polygon p,Segment l);",
                "int intersectCC(Circle c1,Circle c2);",
                "bool intersectSC(Segment s,Circle c);",
                "double getDistanceLP(Line l,Point p);",
                "double getDistanceSP(Segment s,Point p);",
                "double getDistanceSS(Segment s1,Segment s2);",
                "Point getCrossPointSS(Segment s1,Segment s2);",
                "Point getCrossPointLL(Line l1,Line l2);",
                "Polygon getCrossPointCL(Circle c,Line l);",
                "Polygon getCrossPointCC(Circle c1,Circle c2);",
                "int contains(Polygon g,Point p);",
                "Polygon andrewScan(Polygon s);",
                "Polygon convex_hull(Polygon ps);",
                "double diameter(Polygon s);",
                "bool isConvex(Polygon p);",
                "double area(Polygon s);",
                "Polygon convexCut(Polygon p,Line l);",
                "Line bisector(Point p1,Point p2);",
                "Vector translate(Vector v,double theta);",
                "vector<Line> corner(Line l1,Line l2);",
                "vector< vector<int> >",
                "segmentArrangement(vector<Segment> &ss, Polygon &ps);",
                "",
                "int ccw(Point p0,Point p1,Point p2){",
                "  Vector a = p1-p0;",
                "  Vector b = p2-p0;",
                "  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;",
                "  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;",
                "  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;",
                "  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;",
                "  return CCW_ON_SEGMENT;",
                "}",
                "",
                "bool intersectSS(Point p1,Point p2,Point p3,Point p4){",
                "  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&",
                "          ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );",
                "}",
                "",
                "bool intersectSS(Segment s1,Segment s2){",
                "  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);",
                "}",
                "",
                "bool intersectPS(Polygon p,Segment l){",
                "  int n=p.size();",
                "  for(int i=0;i<n;i++)",
                "    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;",
                "  return 0;",
                "}",
                "",
                "int intersectCC(Circle c1,Circle c2){",
                "  if(c1.r<c2.r) swap(c1,c2);",
                "  double d=abs(c1.c-c2.c);",
                "  double r=c1.r+c2.r;",
                "  if(equals(d,r)) return ICC_CIRCUMSCRIBE;",
                "  if(d>r) return ICC_SEPERATE;",
                "  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;",
                "  if(d+c2.r<c1.r) return ICC_CONTAIN;",
                "  return ICC_INTERSECT;",
                "}",
                "",
                "bool intersectSC(Segment s,Circle c){",
                "  return getDistanceSP(s,c.c)<=c.r;",
                "}",
                "",
                "int intersectCS(Circle c,Segment s){",
                "  if(norm(project(s,c.c)-c.c)-c.r*c.r>EPS) return 0;",
                "  double d1=abs(c.c-s.p1),d2=abs(c.c-s.p2);",
                "  if(d1<c.r+EPS&&d2<c.r+EPS) return 0;",
                "  if((d1<c.r-EPS&&d2>c.r+EPS)||(d1>c.r+EPS&&d2<c.r-EPS)) return 1;",
                "  Point h=project(s,c.c);",
                "  if(dot(s.p1-h,s.p2-h)<0) return 2;",
                "  return 0;",
                "}",
                "",
                "double getDistanceLP(Line l,Point p){",
                "  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));",
                "}",
                "",
                "double getDistanceSP(Segment s,Point p){",
                "  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);",
                "  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);",
                "  return getDistanceLP(s,p);",
                "}",
                "",
                "double getDistanceSS(Segment s1,Segment s2){",
                "  if(intersectSS(s1,s2)) return 0.0;",
                "  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),",
                "             min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));",
                "}",
                "",
                "Point getCrossPointSS(Segment s1,Segment s2){",
                "  for(int k=0;k<2;k++){",
                "    if(getDistanceSP(s1,s2.p1)<EPS) return s2.p1;",
                "    if(getDistanceSP(s1,s2.p2)<EPS) return s2.p2;",
                "    swap(s1,s2);",
                "  }",
                "  Vector base=s2.p2-s2.p1;",
                "  double d1=abs(cross(base,s1.p1-s2.p1));",
                "  double d2=abs(cross(base,s1.p2-s2.p1));",
                "  double t=d1/(d1+d2);",
                "  return s1.p1+(s1.p2-s1.p1)*t;",
                "}",
                "",
                "Point getCrossPointLL(Line l1,Line l2){",
                "  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);",
                "  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);",
                "  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;",
                "  return l2.p1+(l2.p2-l2.p1)*(b/a);",
                "}",
                "",
                "Polygon getCrossPointCL(Circle c,Line l){",
                "  Polygon ps;",
                "  Point pr=project(l,c.c);",
                "  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);",
                "  if(equals(getDistanceLP(l,c.c),c.r)){",
                "    ps.emplace_back(pr);",
                "    return ps;",
                "  }",
                "  double base=sqrt(c.r*c.r-norm(pr-c.c));",
                "  ps.emplace_back(pr+e*base);",
                "  ps.emplace_back(pr-e*base);",
                "  return ps;",
                "}",
                "",
                "Polygon getCrossPointCS(Circle c,Segment s){",
                "  Line l(s);",
                "  Polygon res=getCrossPointCL(c,l);",
                "  if(intersectCS(c,s)==2) return res;",
                "  if(res.size()>1u){",
                "    if(dot(l.p1-res[0],l.p2-res[0])>0) swap(res[0],res[1]);",
                "    res.pop_back();",
                "  }",
                "  return res;",
                "}",
                "",
                "",
                "Polygon getCrossPointCC(Circle c1,Circle c2){",
                "  Polygon p(2);",
                "  double d=abs(c1.c-c2.c);",
                "  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));",
                "  double t=arg(c2.c-c1.c);",
                "  p[0]=c1.c+polar(c1.r,t+a);",
                "  p[1]=c1.c+polar(c1.r,t-a);",
                "  return p;",
                "}",
                "",
                "// IN:2 ON:1 OUT:0",
                "int contains(Polygon g,Point p){",
                "  int n=g.size();",
                "  bool x=false;",
                "  for(int i=0;i<n;i++){",
                "    Point a=g[i]-p,b=g[(i+1)%n]-p;",
                "    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;",
                "    if(a.y>b.y) swap(a,b);",
                "    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;",
                "  }",
                "  return (x?2:0);",
                "}",
                "",
                "Polygon andrewScan(Polygon s){",
                "  Polygon u,l;",
                "  if(s.size()<3) return s;",
                "  sort(s.begin(),s.end());",
                "  u.push_back(s[0]);",
                "  u.push_back(s[1]);",
                "  l.push_back(s[s.size()-1]);",
                "  l.push_back(s[s.size()-2]);",
                "  for(int i=2;i<(int)s.size();i++){",
                "    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){",
                "      u.pop_back();",
                "    }",
                "    u.push_back(s[i]);",
                "  }",
                "  for(int i=s.size()-3;i>=0;i--){",
                "    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){",
                "      l.pop_back();",
                "    }",
                "    l.push_back(s[i]);",
                "  }",
                "  reverse(l.begin(),l.end());",
                "  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);",
                "  return l;",
                "}",
                "",
                "Polygon convex_hull(Polygon ps){",
                "  int n=ps.size();",
                "  sort(ps.begin(),ps.end(),sort_y);",
                "  int k=0;",
                "  Polygon qs(n*2);",
                "  for(int i=0;i<n;i++){",
                "    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;",
                "    qs[k++]=ps[i];",
                "  }",
                "  for(int i=n-2,t=k;i>=0;i--){",
                "    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;",
                "    qs[k++]=ps[i];",
                "  }",
                "  qs.resize(k-1);",
                "  return qs;",
                "}",
                "",
                "double diameter(Polygon s){",
                "  Polygon p=s;",
                "  int n=p.size();",
                "  if(n==2) return abs(p[0]-p[1]);",
                "  int i=0,j=0;",
                "  for(int k=0;k<n;k++){",
                "    if(p[i]<p[k]) i=k;",
                "    if(!(p[j]<p[k])) j=k;",
                "  }",
                "  double res=0;",
                "  int si=i,sj=j;",
                "  while(i!=sj||j!=si){",
                "    res=max(res,abs(p[i]-p[j]));",
                "    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){",
                "      i=(i+1)%n;",
                "    }else{",
                "      j=(j+1)%n;",
                "    }",
                "  }",
                "  return res;",
                "}",
                "",
                "bool isConvex(Polygon p){",
                "  bool f=1;",
                "  int n=p.size();",
                "  for(int i=0;i<n;i++){",
                "    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);",
                "    f&=t!=CCW_CLOCKWISE;",
                "  }",
                "  return f;",
                "}",
                "",
                "double area(Polygon s){",
                "  double res=0;",
                "  for(int i=0;i<(int)s.size();i++){",
                "    res+=cross(s[i],s[(i+1)%s.size()])/2.0;",
                "  }",
                "  return res;",
                "}",
                "",
                "double area(Circle c1,Circle c2){",
                "  double d=abs(c1.c-c2.c);",
                "  if(c1.r+c2.r<=d+EPS) return 0;",
                "  if(d<=abs(c1.r-c2.r)){",
                "    double r=min(c1.r,c2.r);",
                "    return PI*r*r;",
                "  }",
                "  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);",
                "  double th=acos(rc/c1.r);",
                "  double ph=acos((d-rc)/c2.r);",
                "  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);",
                "}",
                "",
                "Polygon convexCut(Polygon p,Line l){",
                "  Polygon q;",
                "  for(int i=0;i<(int)p.size();i++){",
                "    Point a=p[i],b=p[(i+1)%p.size()];",
                "    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);",
                "    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)",
                "      q.push_back(getCrossPointLL(Line(a,b),l));",
                "  }",
                "  return q;",
                "}",
                "",
                "Line bisector(Point p1,Point p2){",
                "  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));",
                "  Polygon p=getCrossPointCC(c1,c2);",
                "  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);",
                "  return Line(p[0],p[1]);",
                "}",
                "",
                "Vector translate(Vector v,double theta){",
                "  Vector res;",
                "  res.x=cos(theta)*v.x-sin(theta)*v.y;",
                "  res.y=sin(theta)*v.x+cos(theta)*v.y;",
                "  return res;",
                "}",
                "",
                "vector<Line> corner(Line l1,Line l2){",
                "  vector<Line> res;",
                "  if(isParallel(l1,l2)){",
                "    double d=getDistanceLP(l1,l2.p1)/2.0;",
                "    Vector v1=l1.p2-l1.p1;",
                "    v1=v1/v1.abs()*d;",
                "    Point p=l2.p1+translate(v1,90.0*(PI/180.0));",
                "    double d1=getDistanceLP(l1,p);",
                "    double d2=getDistanceLP(l2,p);",
                "    if(abs(d1-d2)>d){",
                "      p=l2.p1+translate(v1,-90.0*(PI/180.0));",
                "    }",
                "    res.push_back(Line(p,p+v1));",
                "  }else{",
                "    Point p=getCrossPointLL(l1,l2);",
                "    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;",
                "    v1=v1/v1.abs();",
                "    v2=v2/v2.abs();",
                "    res.push_back(Line(p,p+(v1+v2)));",
                "    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));",
                "  }",
                "  return res;",
                "}",
                "",
                "Polygon tangent(Circle c1,Point p2){",
                "  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));",
                "  Polygon p=getCrossPointCC(c1,c2);",
                "  sort(p.begin(),p.end());",
                "  return p;",
                "}",
                "",
                "vector<Line> tangent(Circle c1,Circle c2){",
                "  vector<Line> ls;",
                "  if(c1.r<c2.r) swap(c1,c2);",
                "  double g=norm(c1.c-c2.c);",
                "  if(equals(g,0)) return ls;",
                "  Point u=(c2.c-c1.c)/sqrt(g);",
                "  Point v=orth(u);",
                "  for(int s=1;s>=-1;s-=2){",
                "    double h=(c1.r+s*c2.r)/sqrt(g);",
                "    if(equals(1-h*h,0)){",
                "      ls.emplace_back(c1.c+u*c1.r,c1.c+(u+v)*c1.r);",
                "    }else if(1-h*h>0){",
                "      Point uu=u*h,vv=v*sqrt(1-h*h);",
                "      ls.emplace_back(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s);",
                "      ls.emplace_back(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s);",
                "    }",
                "  }",
                "",
                "  return ls;",
                "}",
                "",
                "double closest_pair(Polygon &a,int l=0,int r=-1){",
                "  if(r<0){",
                "    r=a.size();",
                "    sort(a.begin(),a.end(),sort_x);",
                "  }",
                "  if(r-l<=1) return abs(a[0]-a[1]);",
                "  int m=(l+r)>>1;",
                "  double x=a[m].x;",
                "  double d=min(closest_pair(a,l,m),closest_pair(a,m,r));",
                "  inplace_merge(a.begin()+l,a.begin()+m,a.begin()+r,sort_y);",
                "",
                "  Polygon b;",
                "  for(int i=l;i<r;i++){",
                "    if(fabs(a[i].x-x)>=d) continue;",
                "    for(int j=0;j<(int)b.size();j++){",
                "      double dy=a[i].y-next(b.rbegin(),j)->y;",
                "      if(dy>=d) break;",
                "      d=min(d,abs(a[i]-*next(b.rbegin(),j)));",
                "    }",
                "    b.emplace_back(a[i]);",
                "  }",
                "  return d;",
                "}",
                "",
                "vector<vector<int> >",
                "segmentArrangement(vector<Segment> &ss, Polygon &ps){",
                "  int n=ss.size();",
                "  for(int i=0;i<n;i++){",
                "    ps.emplace_back(ss[i].p1);",
                "    ps.emplace_back(ss[i].p2);",
                "    for(int j=i+1;j<n;j++)",
                "      if(intersectSS(ss[i],ss[j]))",
                "        ps.emplace_back(getCrossPointSS(ss[i],ss[j]));",
                "  }",
                "  sort(ps.begin(),ps.end());",
                "  ps.erase(unique(ps.begin(),ps.end()),ps.end());",
                "",
                "  vector<vector<int> > G(ps.size());",
                "  for(int i=0;i<n;i++){",
                "    vector<pair<double,int> > ls;",
                "    for(int j=0;j<(int)ps.size();j++)",
                "      if(getDistanceSP(ss[i],ps[j])<EPS)",
                "        ls.emplace_back(make_pair(norm(ss[i].p1-ps[j]),j));",
                "",
                "    sort(ls.begin(),ls.end());",
                "    for(int j=0;j+1<(int)ls.size();j++){",
                "      int a=ls[j].second,b=ls[j+1].second;",
                "      G[a].emplace_back(b);",
                "      G[b].emplace_back(a);",
                "    }",
                "  }",
                "  for(auto &v:G){",
                "    sort(v.begin(),v.end());",
                "    v.erase(unique(v.begin(),v.end()),v.end());",
                "  }",
                "  return G;",
                "}",
                "",
                "int manhattanIntersection(vector<Segment> ss,const int inf){",
                "  const int BTM = 0;",
                "  const int LFT = 1;",
                "  const int RGH = 2;",
                "  const int TOP = 3;",
                "",
                "  int n=ss.size();",
                "  vector<EndPoint> ep;",
                "  for(int i=0;i<n;i++){",
                "    if(ss[i].p1.y==ss[i].p2.y){",
                "      if(ss[i].p1.x>ss[i].p2.x) swap(ss[i].p1,ss[i].p2);",
                "      ep.emplace_back(ss[i].p1,i,LFT);",
                "      ep.emplace_back(ss[i].p2,i,RGH);",
                "    }else{",
                "      if(ss[i].p1.y>ss[i].p2.y) swap(ss[i].p1,ss[i].p2);",
                "      ep.emplace_back(ss[i].p1,i,BTM);",
                "      ep.emplace_back(ss[i].p2,i,TOP);",
                "    }",
                "  }",
                "  sort(ep.begin(),ep.end());",
                "",
                "  set<int> bt;",
                "  bt.insert(inf);",
                "",
                "  int cnt=0;",
                "  for(int i=0;i<n*2;i++){",
                "    if(ep[i].st==TOP){",
                "      bt.erase(ep[i].p.x);",
                "    }else if(ep[i].st==BTM){",
                "      bt.emplace(ep[i].p.x);",
                "    }else if(ep[i].st==LFT){",
                "      auto b=bt.lower_bound(ss[ep[i].seg].p1.x);",
                "      auto e=bt.upper_bound(ss[ep[i].seg].p2.x);",
                "      cnt+=distance(b,e);",
                "    }",
                "  }",
                "",
                "  return cnt;",
                "}",
                "",
                "double area(Polygon ps,Circle c){",
                "  if(ps.size()<3u) return 0;",
                "  function<double(Circle, Point, Point)> dfs=",
                "    [&](Circle c,Point a,Point b){",
                "      Vector va=c.c-a,vb=c.c-b;",
                "      double f=cross(va,vb),res=0;",
                "      if(equals(f,0.0)) return res;",
                "      if(max(abs(va),abs(vb))<c.r+EPS) return f;",
                "      Vector d(dot(va,vb),cross(va,vb));",
                "      if(getDistanceSP(Segment(a,b),c.c)>c.r-EPS)",
                "        return c.r*c.r*atan2(d.y,d.x);",
                "      auto u=getCrossPointCS(c,Segment(a,b));",
                "      if(u.empty()) return res;",
                "      if(u.size()>1u&&dot(u[1]-u[0],a-u[0])>0) swap(u[0],u[1]);",
                "      u.emplace(u.begin(),a);",
                "      u.emplace_back(b);",
                "      for(int i=1;i<(int)u.size();i++)",
                "        res+=dfs(c,u[i-1],u[i]);",
                "      return res;",
                "    };",
                "  double res=0;",
                "  for(int i=0;i<(int)ps.size();i++)",
                "    res+=dfs(c,ps[i],ps[(i+1)%ps.size()]);",
                "  return res/2;",
                "}",                
            ],
            "description": "幾何"
    }

}
